**20191118 알고리즘 인강 3강<다이나믹 프로그래밍(문제풀이3)>**

### boj11053 문제( 가장 긴 증가하는 부분 수열 문제, LIS)
> 수열 A가 주어졌을때, 가장 긴 증가하는 부분 수열을 구하는 문제<br/>
*부분 수열: 수열중 일부를 선택한 수열(이때 순서가 바뀌면 안됨)<br/>

D[i] = A[1], … , A[i]까지의 수열이 있을때,<br/> 
`A[i]를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이`라고 정의하면<br/>
D[i]에는 A[i]가 반드시 포함되어야 함<br/>

A[i]가 있다고 하면<br/>
… , A[j], A[i] <br/>
위와 같이 A[i] 앞에 있는 A[j]를 찾으면 됨.<br/>
그리고 A[j]까지의 최대 길이는 D[j]이고<br/>
A[i]까지의 길이 D[i]는 D[j]+1이 됨.<br/>
<br/>
즉 `D[i] = max(D[j]) + 1`이다<br/>
<br/>
그럼 이 j의 조건을 보면<br/>
A[j]가 A[i] 보다 앞에 있어야 하므로 -> `j < i`<br/>
증가하는 부분수열이기 때문에 -> `A[j] < A[i]`<br/>
<br/>
이렇게 두가지 조건이 있다.<br/>

```
코드>
for ( int i=0; i<n; i++) {
    d[i] = 1;
    for ( int j=0; j<i; j++) {
        if (a[j]<a[i] && d[i] < d[j]+1) {
            d[i]  = d[j] + 1;
		}
	}
}
```
> 시간복잡도 : 총 N개의 칸을 채워야 하고<br/>
한 칸을 채울 때 앞의 N-1개의 칸을 비교하므로<br/>
시간복잡도는 O(N^2)이다.<br/>





<br/>
<br/>
<br/>
<br/>




### boj11055 문제( 가장 큰 증가하는 부분 수열 문제)
> 수열 A가 주어졌을때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 문제<br/>
-> 위 문제와 컨셉을 똑같다!<br/>

위 문제에서는 j<i와 A[j] < A[i]를 만족하는 j 중에서<br/>
max(D[j]) + 1 을 했다. //+1은 길이를 구하는 문제이기 때문에<br/>
하지만 이번 문제는 합을 구하는 문제이기 때문에 `+1` 부분을 `+A[i]`를 넣으면 된다.<br/>

```
코드>
for ( int i=0; i<n; i++) {
    d[i] = a[i]; //길이가 아니라 합 이므로 1이 아니라 그 값으로 초기화
    for ( int j=0; j<i; j++) {
        if (a[j]<a[i] && d[i] < d[j]+1) {
            d[i]  = d[j] + a[i]; //길이가 아니라 합 이므로 +1이 아니라 그 a[i] 값으로 초기화
```



<br/>
<br/>
<br/>
<br/>





### boj11722 문제( 가장 긴 감소하는 부분 수열 문제)
> 수열 A가 주어졌을 때, 그 수열의 감소하는 부분 수열 중에서 합이 가장 큰 것을 구하는 문제.<br/>
맨 위 문제와 조건만 다름

sol1)입력으로 주어진 수열A를 뒤집어서 Ar 배열을 만들고<br/>
-> 가장 긴 증가하는 부분 수열을 구하는 방법(LIS 문제)<br/>
<br/>
sol2)가장 긴 증가하는 부분 수열과 비슷하게 구하는 방법(뒤에서부터 구해야 함!)





<br/>
<br/>
<br/>
<br/>




### boj11054 문제( 가장 긴 바이토닉 부분 수열 문제)
> 증가했다가 감소하는 부분순열을 구하는 문제.

-> 가장 긴 증가하는 부분 수열(D)과 가장 긴 감소하는 부분 수열(D2)를 구한 다음 <br/>
`D[i] + D2[i] -1`이 가장 큰 값을 찾으면 됨.<br/>
(-1을 하는 이유는 꼭지점?이 두번 카운트 되기 때문)


<br/>
<br/>
<br/>
<br/>


### boj1912 문제( 연속합 문제)
> n개의 정수로 이루어진 임의의 수열이 주어지고<br/>
이 중 연속된 몇 개의 숫자를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하는 문제.<br/>
(단, 숫자는 한 개 이상 선택해야 함)<br/>

ex) 5, -1, 5<br/>
-> 음수를 포함해도 최대가 나오는 경우 있음<br/>


이때 `D[i]를 "A[i]로 끝나는 최대 연속합"`이라고 정의하면<br/>
(A[i]가 연속합에 포함되지 않은 경우를 고려할 필요가 없다…?)<br/>
<br/>
다음과 같은 두가지 경우가 있다.<br/>
<br/>

**1) A[i-1]로 끝나는 연속합의 연장인 경우**<br/>
`D[i] = D[i-1] + A[i];`<br/><br/>

**2) 새로운 연속합의 시작인 경우**<br/>
(즉, 앞에꺼 다 버리고 A[i]만 합하는게 가장 클 경우)<br/>
`D[i] = A[i];`<br/>
<br/>
이렇게 D[] 배열을 다 구한 다음에 최댓값을 구하면 됨.<br/>
<br/>
```
코드>
for ( int i=0; i<n; i++) {
    d[i] = a[i];
    if (i==0) continue;
    if (d[i] < d[i-1] + a[i]) }
        d[i] = d[i-1] + a[i];
    }
}
```
> 시간복잡도 : 총 N개의 칸을 구해야 하는데<br/>
각 칸을 구할때 자기자신과 앞 칸만 비교하므로<br/>
시간복잡도는 O(N)이 된다.<br/>
<br/>

**tip) 최댓값을 구할때 많은 사람들이**<br/>
```
코드>
int ans=0;
for (int i=0~n) {
    if (ans < d[i]) {
        ans = d[i];
    }
}
```
위와 같이 많이 짜는데 이 문제는 이와같이 짜면 풀 수 없다.<br/>
왜냐하면 음수가 있기 때문에!!<br/>
<br/>
초기값을 0으로 하지 말고 <br/>
int의 최솟값 `-2147483648`로 설정하거나<br/>
`ans = d[0]`으로 하고 `for 문을 1부터` 돌면 된다.<br/>



<br/>
<br/>
<br/>
<br/>


to be continue...

<br/>
<br/>
<br/>
<br/>
