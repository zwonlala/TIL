[송지원 전반적인 예시 코드는 생략함]

## 10.1 맵
## 10.2 위크맵
## 10.3 셋
## 10.4 위크셋
## 10.5 정리

<br>
<br>

## 10. 맵과 셋

ES6에 새로 도입된 데이터 구조
- 맵(map) : 키와 값을 연결한다는 점에서 객체와 유사
- 셋(set) : 중복을 허용하지 않는 점 제외하면 배열과 비슷


## 10.1 맵

ES6 이전에는 키와 값을 연결하려면 '객체'를 사용했어야 함
~> 하지만 '객체' 사용시 단점이 있음

- 프로토타입 체인 때문에 의도하지 않은 연결이 생길 수 있음
- 객체 안에 연결된 키와 값이 몇개나 되는지 쉽게 알아낼 수 있는 방법이 없음
- 키는 반드시 문자열이나 심볼이어야 하므로, 객체를 키로 써서 값과 연결할 수 없음
- 객체는 프로퍼티 순서를 전혀 보장하지 않음

Map 객체는 위 문제를 해결하였고,  
키와 값을 연결할 목적이라면 객체보다 나은 선택임

- 맵의 생성
- set() 메소드
- get() 메소드
- has() 메소드
- size 프로퍼티

- keys()   
맵의 키 리턴
- values()   
맵의 값 리턴
- entries()   
첫번째 요소가 키이고 두번째 요소가 값인 배열을 각각 반환

위 세 함수의 모든 리턴값은 iterable 객체 =>  for of 루프 사용 가능!   

- 배열이 필요하면   
values() 메소드와 ...(스프레드) 연산자 사용하면 됨

- delete() 메소드   
맵의 요소 지울 때

- clear() 메소드    
맵의 요소 모두 삭제


## 10.2 위크맵
위크맵(WeakMap)은 맵에 다음과 같은 조건이 붙는 것

- 키는 반드시 객체이어야 함
- WeakMap의 키는 가비지 콜렉션에 포함될 수 있음
- WeakMap은 이터러블이 아니며, clear() 메소드도 없음

일반적으로 JS는 객체를 참조하고 있으면, 그 객체를 메모리에 계속 유지함   
ex)Map의 키인 객체 o가 있다면, JS는 Map이 존재하는 한, o를 메모리에 계속 유지함!
but WeakMap에서는 그렇지 않음!
=> WeakMap은 iterable이 될 수 없음.
=> 이러한 WeakMap의 특징은 객체 인스턴스의 전용 키(private key)를 저장하기 알맞음



## 10.3 셋

셋은 중복을 허락하지 않는 데이터 집합    
- 셋의 생성
- add() 메소드
set의 장점 : 이미 추가한 프로퍼티인지 확인할 필요 없음!
- size 프로퍼티
- delete() 메소드

## 10.4 위크셋
위크셋은 객체만 포함될 수 있음 & 해당 객체들은 가비지 콜렉션의 대상이 됨

## 10.5 요약
생략
