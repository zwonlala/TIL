## 7.1 스코프와 존재
## 7.2 정적 스코프와 동적 스코프
## 7.3 전역 스코프
## 7.4 블록 스코프
## 7.5 변수 숨기기
## 7.6 함수, 클로저, 정적 스코프
## 7.7 즉시 호출하는 함수 표현식
## 7.8 함수 스코프와 호이스팅
## 7.9 함수 호이스팅
## 7.10 사각지대
## 7.11 스트릭트 모드
## 7.12 요약
 
<br>
<br>

## 7.스코프

스코프(scope)는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정

> 스코프를 시야, 범위라고 읽으면 이해하기 쉬움

Ex 함수 매개변수가 함수 바디 안에서만 존재하는 것

```
funtion f(x) {
  return x + 3;
}

f(5);	//8
x;		//ReferencdError: x is not defined

```

함수 f를 벗어나면 x가 존재하지 않는 것 처럼 보임
∴ 'x의 스코프가 함수 f라고 말함'


> 선언(declaration) VS 정의(definition) 
  
	- 선언 : 식별자를 주어서 그 존재를 알리는 것
		- ex) 이 변수의 이름은 X야~. 이제부터 이 친구를 X라고 부를꺼야~  
	- 정의 : 선언과 함께 값도 부여하는 것
		- ex) 이 변수의 이름은 Y인데, Y의 값은 3이야~  
		- 수학에서 '정의' 하라고 하면 \~\~는(===) \~\~다 라고 하는거니, 어떠한 값이라는 정보를 주어줘야 한다고 생각하면 쉬울 듯  
	- 하지만 JS에서는 모든 변수를 선언하는 동시에 값(undefined)이 주어지므로, '선언'과 '정의'를 구분하지 않음

<br>
<br>
<br>

## 7.1 스코프와 존재

스코프 vs 존재.  
스코프와 존재의 차이를 구분할 수 있어야 함.  


스코프 : 가시성(visibility) 라고도 불림.   
프로그램의 현재 실행 중인 부분(실행 컨텍스트, execution context)에서 현재 보이고 접근할 수 있는 식별자.  

존재한다 : 해당 식별자가 메모리가 할당된 무언가를 가리키고 있다

> 가비지 콜렉션(garbage collection).  
무언가가 더는 존재하지 않는다고 해도 JS는 메모리를 바로 회수하지는 않음.  
그것을 계속 유지할 필요가 없다고 표시해두면, 주기적으로 일어자는 GC 프로세스에서 메모리를 회수


<br>
<br>
<br>

## 7.2 정적 스코프와 동적 스코프

프로그램의 소스 코드를 살펴보는 건 프로그램의 정적(어휘적, lexical) 구조를 살펴보는 것.  
하지만 프로그램이 실행되면 실행흐름은 이곳 저곳으로 움직임.  

JS의 스코프는 정적 스코프.  
(즉, 소스코드만 봐도 변수가 스코프에 있는지 판단할 수 있음 ?!?).  
(어던 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있음. 호출할때 알 수 있는 건 X).   

```javascript
const x = 3;

function f() {
  console.log(x);
  console.log(y);
}

{ 
  //새 스코프
  const y = 5;
  f();
}
```

* 변수 x : 함수 f 를 정의할 때 존재
* 변수 y : 함수 f 를 정의할 때 존재 X (다른 스코프에 있음)

다른 스코프에서 y를 선언하고 그 스코프에서 f를 호출하더라도,      
f를 호출하면 x는 그 함수 바디 안에 있지만, y는 그렇지 않음.  
=> 이것이 정적 스코프!  


JS의 정적 스코프는.  
* 전역 스코프 global scope
* 블록 스코프 block scope
* 함수 스코프 function scope.   
에 적용 됨   

<br>
<br>
<br>

## 7.3 전역 스코프

프로그램이 시작할 때 암시적으로 주어지는 스코프.    
그 스코프를 전역 스코프라고 함.  
     
<br>

JS가 프로그램을 시작할 때, 즉 어떤 함수도 호출하지 않았을 때 실행 흐름은 전역 스코프에 있음     
=> 전역 스코프에 정의된 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있음.     

<br>

전역 스코프에 선언된 것들을 전역 변수라고 함.     

전역 변수는 나쁜게 아님.     
전역 변수는 반드시 써야 함      
나쁜건 전역 스코프를 남용하는 것.     
(전역 스코프에 의존하는 걸 피해야 한다).       

<br>
<br>
<br>

## 7.4 블록 스코프

let과 Const는 식별자를 블록 스코프에 선언함.    

블록은 문을 중괄호로 묶은 것.    

블록 스코프는 스코프에만 보이는 식별자를 의미???       

<br>
<br>
<br>

## 7.5 변수 숨기기

스코프가 중첩되는 경우 살짝 헷갈릴 수 있음.    

```
{
  //외부 블록
  let x = 'blue';
  console.log(x); //'blue'

  {
    //내부 블록
    let x = 3;
    console.log(x); //3	
  }

  console.log(x); //'blue'
}

console.log(x); //undefined. x는 스코프에 있지 않음
```

위 예제는 변수 숨김(Variable masking)을 보여주는 사례임.      

<br>

내부 블록의 x는 외부 블록에서 정의한 x와 이름만 같을 뿐 다른 변수이므로,        
외부 스코프의 x를 숨기는(가리는) 효과가 있음.  

<br>

여기서 중요한 점은  
실행 흐름이 내부 블록에 들어가 새 변수 x를 정의하는 순간, 두 변수가 모두 스코프 안에 있다는 것  
(변수의 이름이 같으므로 외부 스코프에 있는 변수에 접근할 방법이 없음)   

<br>


```
{
  //외부 블록
  let x = { color: 'blue' };
  let y = x;
  let z = 3;

  {
    //내부 블록
    let x = 5;					//이제 바깥의 x는 가려짐
    console.log(x); 			//5
    console.log(y.color); //'blue'
    y.color = 'red';
    console.log(z); 			//3. z는 가려지지 않음
  }. 

  console.log(x.color);		//'red'
  console.log(y.color);		//'red'
  console.log(z);				//3
```


스코프는 계층적
   
스코프의 계층적인 성격 때문에 어떤 변수가 스코프에 있는지 확인하는       
스코프 체인(scope chain)이라는 개념이 생김     

현재 스코프 체인에 있는 모든 변수는 스코프에 있는 것이며, 숨겨지지 않았다면 접근할 수 있음  

<br>
<br>
<br>

## 7.6 함수, 클로저, 정적 스코프

블록과 다르게 함수는 여기저기서 정의하고 호출하므로 스코프를 확인하기가 블록보다는 번거로움    

모든 함수를 전역에서 정의하고, 함수 안에서 전역 스코프를 참조하지 않도록 하는 전통적 프로그램에서는  
함수가 어떤 스코프에 접근할 수 있는지 생각할 필요가 없음  

<br>


하지만 최신 JS에서는 함수가 필요한 곳에서 즉석으로 정의할 때가 많음  

* 함수를 변수나 객체 프로퍼티에 할당
* 함수를 배열에 추가
* 함수를 다른 함수에 전달
* 함수가 함수를 반환
* 이름 없는 함수
* ...


<br>
<br>


함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우가 많음   
그런 것을 클로져(Closure)라고 함  
(스코프를 함수 주변으로 좁히는(closing) 것이라고 생각하면 됨)

<br>


```
let globalFunc;

{
  let blockVar = 'a';
  globalFunc = function() {
    console.log(blockVar);
  }
}

globalFunc();		//'a'
```
위 예제에서 globalFunc는 블록 안에서 값을 할당받음.  
이 블록 스코프와 그 부모인 전역 스코프가 클로져를 형성

<br>

globalFunc 함수를 어디서 호출하든, 이 함수는 클로져에 들어있는 식별자에 접근할 수 있음 


globalFunc를 호출하면, 이 함수는 스코프를 빠져나왔음에도 불구하고 blockVar에 접근할 수 있음   
 
(일반적으로 스코프를 벗어나면 해당 스코프에서 선언한 변수는 메모리에서 제거되지만,   
위 예제에서는 스코프 안에 함수를 정의했고,    
해당 함수는 스코프 밖에서도 참조할 수 있으므로 JS는 스코프를 계속 유지)

<br>

스코프 안에 함수를 정의하면 해당 스코프는 더 오래 유지됨    

<br>

또 일반적으로 접근할 수 없는 것에 접근할 수 있는 효과도 있음

```
let f;

{
  let o = { note: 'Safe' };
  f = funtion() {
    return o;
  }
}

let oRef = f();
oRef.note = 'Not so safe after all!';
```

일반적으로 스코프 바깥에 있는 것들에는 접근할 수 없으나,    
함수를 정의해 클로져를 만들면 접근할 수 없었던 것들에 접근할 방법이 생김.


<br>
<br>
<br>

## 7.7 즉시 호출하는 함수 표현식

6장에서 설명한 함수 표현식을 사용하면 즉시 호출하는 함수 표현식(IIFE)이란 것을 만들 수 있음

IIFE는 함수를 선언하고 즉시 실행함.  

스코프와 클로져에 대해 충분히 이해했으니 왜 IIFE를 사용해야 하는지 이해할 수 있을 것


```
(function() {
  //IIFE 바디
})();
```
IIFE는 바로 위와 같은 형태를 취함    

함수 표현식으로 익명 함수를 만들고     
그 함수를 즉시 호출함  

<br>

IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만,          
IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다는 것  

```
const message = (function() {
  const secret = `I'm a secret`;
  return `The secret is ${secret.length} charecters long.`;
})();

console.log(message);
```

변수 secret는 IIFE의 스코프 안에 안전하게 보호되며 외부에서 접근할 수 없음

<br>
    
IIFE는 함수이므로 무엇이든 반환할 수 있음    
IIFE에서 배열, 객체, 함수를 반환하는 경우도 많음  

<br>
<br>

ex) 자신이 몇번 호출되었는지 보고하는 함수  
-> 이 함수가 몇 번 호출되었는지 저장한 값을 외부에서는 절대 손댈 수 없음 

```
const f = (function() {
  let count = 0;
  return function() {
    return `I have been called ${++count} times.`;
  }
})();


f(); //'I have been called 1 times.'
f(); //'I have been called 2 times.'
f(); //'I have been called 3 times.'
```

변수 count는 IIFE 안에 안전하게 보관되어 있으므로 손댈 방법이 없음     
함수 f는 자신이 몇번 호출되었는지 항상 정확히 알고 있음  

ES6에서 블록 스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄어들긴 함    
하지만 클로져를 만들고, 클로져에서 무언가 반환받을때에는 유용하게 쓸 수 있음  

<br>
<br>
<br>


## 7.8 함수 스코프와 호이스팅
var 를 사용하여 선언된 변수들은 함수 스코프를 가짐.

- let으로 변수 선언하면, 해당 변수 선언하기 전에는 존재하지 않음

```
x;		//Reference Error: x는 정의되지 않았음
let x = 3;
```

- var로 변수 선언하면, 현재 스코프 안이라면 어디서든 사용할 수 있으며, 선언하기도 전에 사용할 수 있음

```
x;		//undefined
var x = 3;
x;		//3
```

'var'로 선언한 변수는 끌어올린다는 뜻의 "호이스팅(hoisting)"이라는 매커니즘을 따름

JS는 함수나, 전역 스코프 전체를 살펴보고, var로 선언한 변수를 맨 위로 끌어올림
=> 선언만 끌어올려지고, 할당을 끌어올려지지 않음

방금 위 예제는 JS는 이렇게 해석함

```
var x;	 	//선언(할당은 X)이 끌어올려짐
x;		//undefined
x = 3;
x;		//3
```


좀더 명확히 이해하기 위해 복잡한 예시 첨부

송지원 200 페이지 첫번째 코드 1, 2 나중에 작성하기
<div style="flex:100%; background-color:green ;display:flex; flex-direction:row; justify-content:flex-start; align-items:flex-start;>

<div style="width:50%; height:60px; display:block; background-color:red;">sdf
dsf
sdf
</div>

<div style="width:50%; height:30px; display:inline-block; background-color:cyan;">
</div>

let으로 가능했던 변수 숨김도 불가능



<br>
<br>
<br>

## 7.9 함수 호이스팅

var로 선언된 변수와 동일하게,
함수 선언도 스코프 맨 위로 끌어올려짐
=> 함수를 선언하기 전 호출할 수 있음!!!

```
f();		//'f'
function f() {
	console.log('f');
}
```

하지만 변수에 할당한 함수 표현식은 끌어올려지지 않음.  
(변수의 스코프 규칙을 따름)

```
f();		//ReferrenceError: f는 정의되지 않았습니다
let f = function() {
	console.log('f');
}
```
<br>
<br>
<br>

## 7.10 사각지대

사각지대(temporal dead zone): let으로 선언하는 변수는 선언하기 전까지 존재하지 않는 다는 직관적인 개념을 잘 나타내는 표현
(스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드)

ES6 이전에는 typeof 연산자를 통해 변수가 선언되었는지 확인하고, 코드를 사용하였음
=> let으로 변수 선언하면 에러 발생

<br>
<br>
<br>

## 7.11 스트릭트 모드

ES5 문법에 '암시적 전역 변수'(implicit global)라는 것이 생길 수 있음
> 암시적 전역 변수 : var로 변수를 선언하는 것을 잊으면, JS는 전역 변수를 참조한다고 간주하고 해당 전역 변수가 존재하지 않으면 스스로 생성함..;;;

=> JS에서 스트릭트 모드(strict mode)를 도입함

스트릭트 모드에서는
- 암시적 전역 변수 허용 X
- 문자열 'use strict' 하나만으로 이루어진 행을 코드 맨 앞에 사용하면 됨
	- 전역 스코프에서 'use strict' 사용 => 스크립트 전체가 스트릭트 모드로 실행
		- => 불러온 스크립트 전체에 스트릭트 모드가 강제됨! 
		- ∴ 전역 스코프에서는 사용을 조심히 해야 함!
		- 해결법 : 코드 전체를 IIFE로 감싼다!!!
	- 함수 안에서 'use strict' 사용 => 해당 함수만 스트릭트 모드로 실행


송지원 204장 맨 위 예시 코드 작성하기

참고하면 좋을 mdn 문서 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode

<br>
<br>
<br>

## 7.12 요약


<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
