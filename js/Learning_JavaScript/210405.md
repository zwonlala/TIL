## 5.1 연산자 
## 5.2 산술 연산자 
## 5.3 연산자 우선순위 
## 5.4 비교 연산자
## 5.5 숫자 비교 
## 5.6 문자열 병합 
## 5.7 논리 연산자
## 5.8 AND, OR, NOT
## 5.9 연산자 그룹

<br>
<br>

### 5.9.3 void 연산자

하는 일: 피연산자를 평가한 후 undefined 반환
거의 쓸모없음
가끔 HTML에서 <a> 태그의 URI에 사용함
-> 브라우져에서 다른 페이지로 이동하는 일 막을 수 있음

<a href="javascript:void 0">Do nothing</a>


### 5.9.4 할당 연산자

전체 표현식의 값은 마지막에 이루어진 할당의 값으로 평가됨

## 5.10 해체 할당

ES6에 새로 도입된 문법

해체 할당(destructing assignment)
객체나 배열을 변수로 '해체' 할 수 있음

```
//객체 선언
const obj = {b:2, c:3, d:4};

//해체 할당
const {a, b, c} = obj;
a; 	//undefined. obj에는 'a' 프로퍼티가 없음
b;	//2
c;	//3
d;	//ReferenceError
```

객체를 해체할 때는 반드시 변수 이름과 객체의 프로퍼티 이름이 일치해야 함!

객체 해체는 할당만으로 이뤄질 수 도 있으나, 그렇게 하려면 반드시 괄호를 써야 함(쓰지 않으면 표현식 좌변을 블록으로 해석)


```
const obj = {b:2, c:3, d:4};
let a, b, c;;;

{a, b, c} = obj; //Error

({a, b, c} = obj); //동작
```


배열을 해체할 때는
배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있고, 배열 순서대로 대응



```
//배열 선언
const arr = [1, 2, 3];

//배열 해체 할당
let [x, y] = arr;
x;	//1
y;	//2
z;	//Reference Error
```
위 예제에서 앞 뒤 요소를 제외한 요소는 모두 버려짐


확산 연산자(spead operator, ...)를 사용하몀 남은 요소를 새 배열에 할당할 수 있음


```
const arr = [1, 2, 3, 4, 5];

let [x, y, ...rest] = arr;

x;		//1
y;		//2
rest;	//[3, 4, 5]
```


배열 해체를 사용하면 temp 변수를 사용하지 않고 변수의 값을 서로 바꿀 수 있음


```
let a = 5, b = 10;

[a, b] = [b, a];

a;	//10
b;	//5
```


배열 해체는 배열 뿐만 아니라 Iterable 객체에서 모두 사용가능함.
해체의 진가는 다른 곳에서 가져온 객체나 배열에서 원하는 요소를 뽑아내야 할 때 드러남


## 5.11 객체외 배열 연산자

<표로 정리>
in 프로퍼티 존재 연산자
new 객체 인스턴스화 연산자
instance of 프로토타입 체인 테스트 연산자
... 확산 연산자
delete 삭제 연산자

## 5.12 템플릿 문자열과 표현식

<생략>

## 5.13 표현식과 흐름 제어 패턴

1. if ~ else ~ 문을 3항 연산자로 바꾸기

```javascript

if (isPrime(n)) {
	label = 'prime';
} else {
	label = 'non-prime';
}



//위와 같은 코드를 3항 연산자를 사용하면 이렇게 간단하게 바뀜

label = isPrime(n) ? 'prime' : 'non-prime';
```


2. if문을 단축평가하는 OR 표현식으로 바꾸기

```
if (!options) options = {};

//위와 같은 코드를 OR 연산자를 사용한 단축평가를 진행하면

options = options || {};

```

## 5.14 요약

<생략>


<br>
<br>
<br>
<br>
<br>
<br>



## 6.1 반환 값
## 6.2 호출과 참조
## 6.3 함수와 매개변수
## 6.4 객체의 프로퍼티인 함수
## 6.5 this 키워드
## 6.6 함수 표현식과 익명 함수
## 6.7 화살표 표기법
## 6.8 call과 apply, bind
## 6.9 요약
 
<br>
<br>

## 6. 함수
함수는 하나의 단위로 실행되는 문의 집합.   
함수는 JS의 강력함과 표현성(expressiveness_PL이 표현적이라는 말은 코드만 봐도 어떤 의도인지 쉽게 알 수 있다는 뜻)의 근간   

함수의 바디 : 함수를 구성하는 문의 모음

함수 선언(function declaration) : 
함수 호출(call) : 함수 이름 다음에 괄호를 씀

## 6.1 반환 값

함수 호출 === 표현식   
그리고 표현식은 값이 됨. 

=> 함수 호출의 값은 반환값(return 키워드)

return 문 명시적으로 호출하지 않으면 반환값은 undefined가 됨
  
## 6.2 호출과 참조

JS에서는 함수도 객체   
∴ 다른 객체와 마찬가지로 넘기거나 할당할 수 있음

함수를 호출하지 않고 다른 값과 마찬가지로 참조하기만 할 수 있다는 특징
=> JS를 매우 유연한 언어로 만듬
(Ex : 함수를 변수, 객체 프로퍼티, 배열 요소에 할당하면 다른 이름으로 함수를 호출할 수 있음)

```
function getGreeting() {
	return 'Hello World!';
}

//함수를 변수에 할당
const f = getGreeting;
f();

//함수를 객체 프로퍼티에 할당
const o = {};
o.f = getGreeting;
o.f();

//함수를 배열 요소로 할당
const arr = [1, 2, 3];
arr[1] = getGreeting;
arr[1]();
```

## 6.3 함수와 매개변수

함수를 호출하면서 정보를 전달할 땐 함수 매개변수(argument, parameter)를 이용

```
function avg(a, b) {
	return (a + b)/2;
}

//이 함수 선언에서 a와 b를 정해진 매개변수(formal argument)


avg(5, 7); //7.5

//함수가 호출되면 정해진 매개변수는 값을 받아 실제 매개변수(actual argument)가 됨
```

함수 안에서 매개변수 값을 할당해도 함수 바깥에 있는 어떤 변수에도 아무런 영향이 없음
but, 함수 안에서 객체 자체를 변경하면, 그 객체는 함수 바깥에서도 바뀐점이 반영

=> 원시값과 객체의 핵심적인 차이

- 원시값(value Type)은 불변 -> 수정할 수 없음  
(원시값을 담은 변수는 수정할 수 O => 다른 값으로 바꿀 수 있다)
- 객체(reference Type)는 바뀔 수 있음


### 6.3.1 매개변수가 함수를 결졍하는가?

여러 PL에서 함수의 시그니쳐(signature)에는 매개변수가 포함
Ex) "C언어"에서 f(), f(x), f(x, y)는 서로 다른 함수

But JS에서는 그런 차이가 없음

∴ 어떤 함수를 호출하던, 그 함수에서 정해진 매개변수 객수와 관계없이 몇 개의 매개변수를 전달해도 됨
(정해진 매개변수를 보내주지 않으면 암시적으로 Undefined 할당됨)


### 6.3.2 매개변수 해체
송지원 여기부터  




## 6.4 객체의 프로퍼티인 함수
## 6.5 this 키워드
## 6.6 함수 표현식과 익명 함수
## 6.7 화살표 표기법
## 6.8 call과 apply, bind
## 6.9 요약
