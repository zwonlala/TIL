[송지원 전반적인 예시 코드는 생략함]

## 9.1 프로퍼티 나열
## 9.2 객체지향 프로그래밍
## 9.3 다중 상속, 믹스인, 인터페이스
## 9.4 요약

 
<br>
<br>


## 9.객체와 객체지향 프로그래밍

JS 객체

- JS 객체와 배열의 비교

	- 공통점 : 컨테이너이다
	- 차이점 : 
		1. 배열은 값을 가지고, 각 값에는 숫자형 인덱스가 있음   
			객체는 프로퍼티를 가지며, 각 프로퍼티에는 문자열이나 심볼 인덱스가 있음
		2. 배열에는 순서가 있음   
			객체에는 순서가 보장되지 않음(보장되는 것 처럼 보여도, 언제든지 바뀔 수 있음)


## 9.1 프로퍼티 나열

순서가 보장되지 않는다..!

### 9.1.1 for ... in

[송지원 224 페이지 아래 코드]
for in 루프에는 키가 심볼인 프로퍼티는 포함되지 않음

- hasOwnProperty() 함수 -> 용도?


### 9.1.2 Object.keys

객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환

hasOwnProperty() 함수 사용할 필요 없음

## 9.2 객체지향 프로그래밍

### 9.2.1 클래스와 인스턴스 생성
ES6에서 클래스를 만드는 새로운 문법을 도입

인스턴스를 만들때는 new 키워드를 사용함

instanceof : 객체가 클래스의 인스턴스인지 확인하는 연산자

this 키워드 : 메소드를 호출한 인스턴스를 가리키는 목적으로 쓰임

프로퍼티를 꼭 보호해야 한다먼, 스코프를 이용해 보호하는 WeakMap 인스턴스를 사용할 수 있음



### 9.2.2 클래스는 함수다

ES6에서 class 키워드가 추가되기 전까지 클래스를 만든다는 건   
"클래스 생성자로 사용할 함수를 만든다는 의미"

클래스는 사실 함수일 뿐. 단지 단축문법을 사용하는 것임.


### 9.2.3 프로토타입

클래스의 인스턴스에서 사용할 수 있는 메소드 : 프로토타입(prototype) 메소드를 의미하는 것  

프로토타입 메소드는 Car.prototype.shift, Array.prototype.forEach 처럼 표기할 때가 많음     
(추가적으로 Car#shift 이렇게 작성할 수도 있음)

모든 함수에는 prototype이라는 특별한 프로퍼티가 있음  		

일반적인 함수에서는 프노토타입을 사용할 일이 없지만, 객체 생성자로 동작하는 함수에서는 프로토 타입이 대단히 중요.   

함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때    
new 키워드로 만든 새 객체는 생성자의 prototype 프로퍼니에 접근할 수 있음    
객체 인스턴스는 생성자의 prototype 프로퍼티를 \_\_proto\_\_ 프로퍼티에 저장     


#### 동적 디스패치

프로토타입에서 중요한 개념은 "동적 디스패치"라는 매커니즘   

여기서 '디스패치'는 '메서드 호출'과 같은 의미  

- 객체의  프로퍼티나 메소드에 접근하려 할때, 그런 프로퍼티나 메소드가 존재하지 않으면  
-> JS는 객체의 프로토타입에서 해당 프로퍼티나 메소드를 찾음  
-> 클래스와 인스턴스는 모두 같은 프로토타입을 공유하므로,   
프로토타입에 프로퍼티나 메소드가 있다면 해당 클래스의 인스턴스는 모두 그 프로퍼티나 메소드에 접근 가능  


인스턴스에서 메소드가 프로퍼티를 정의하면,  
프로토타입에 있는 것을 가리는 효과가 있다.  
(∵ JS에서는 인스턴스를 먼저 체크하고, 없으면 프로토타입을 체크하기 때문)  



### 9.2.4 정적 메소드

메소드는 인스턴스 메소드 외에도 정적 메소드(클래스 메소드)가 있음  

정적 메소드에서 this는 인스턴스가 아니라, 클래스 자체에서 묶임  
-> 일반적으로 정적 메소드에서는 this 대신 클래스 이름을 사용하는 것이 좋은 습관!?!(아닛 이게 문법적으로 허용되는 것이었다니 소오름)  

정적 메소드는 클래스에는 관련되지만, 인스턴스와는 관련이 없는 범용적인 작업에 사용됨  
또 여러 인스턴스를 대상으로 하는 작업에도 종종 쓰임  


### 9.2.5 상속

클래스의 인스턴스는 클래스의 기능을 모두 상속함   

객체의 프로토타입에서 메소드를 찾지 못하면, JS는 프로토타입의 프로토타입을 검색  

=> 프로토타입 체인은 이런 식으로 만들어짐  

조건에 맞는 프로토타입을 찾을때까지 체인을 계속 거슬러 올라가다가,  
조건에 맞는 프로토타입을 찾지 못하면 에러를 일으킴  



클래스의 계층 구조를 만들 때  
=> 프로토타입 체인을 염두해두면 효율적인 구조를 만들 수 있음  
ex) 슈퍼클래스 Vehicle에 addPassenger() 함수  
서브 클래스 Car에 deployAirBag() 함수를 정의  


### 9.2.6 다형성(Polymorphism)

- 다형성 : 여러 슈퍼클래스의 멤버인 인스턴스를 가리키는 말  

### 9.2.7 객체 프로퍼티 나열 다시 보기

- hasOwnProperty() 함수 :   
객체 obj와 프로퍼티 x에서   
obj.hasOwnProtperty(x)는   
- obj에 프로퍼티 x가 있다면 true를 반환  
- 프로퍼티 x가 정의되지 않았거나, 프로토타입 체인에만 정의되어 있음 false 리턴  

송지원 237 페이지 마지막 예시 코드 작성하기  
=> name, isSuper, isSub 프로퍼티 모두 프로토타입 체인이 아닌 인스턴스에 정의  
(슈퍼 클래스 생성자에서 선언한 프로퍼티는 서브 클래스 인스턴스에도 정의됨)  




### 9.2.8 문자열 표현

모든 객체는 Object 상속  
=> Object의 메소드는 모든 객체에서 사용 가능  

ex) toString() 함수  
toString()의 기본 동작은 "[object Object]"를 반환하는 것(무쓸모)  
-> 객체에 관한 중요한 정보 제공  




## 9.3 다중 상속, 믹스인, 인터페이스

다중상속.  
-> 충돌의 위험이 있음  
(두 슈퍼클래스에 동일한 이름의 메소드가 있다면, 서브 클래스는 어느 쪽의 메소드를 상속해야 함? ㅇㅁㅇ)  
=> 인터페이스라는 개념을 사용하기도 함  
=> JS는 해당 문제에 대한 답변으로 믹스인 mixin이라는 개념을 내놓음  

믹스인 : 기능을 필요한 만큰 섞어 놓은 것  



송지원 240, 241 페이지 예시 작성하기~  



## 9.4 요약

생략



