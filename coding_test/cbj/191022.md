**20191022 알고리즘 인강 2강<자료구조1(스택 part)>**

# **스택(Stack)**
```
- 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 자료구조
- 마지막으로 넣은 것이 가장 먼저 나오므로 Last In First Out (LIFO)구조라고 한다
- push: 스택에 자료를 넣는 연산
- pop: 스택에 있는 자료를 빼는 연산
- top : 스택에 가장 위에 있는 자료를 보는 연산
- empty : 스택이 비어있는지 아닌지를 알아보는 연산
- size : 스택에 저장되어 있는 자료의 개수를 알아보는 연산
- C++의 경우 STL의 stack, JAVA의 경우 java.util.Stack을 사용
```

스택을 실제로 구현하기 위해서는 배열과 size 변수(저장되어 있는 변수의 갯수)가 필요.

처음엔 배열이 비어져 있고, size 변수는 0 값으로 초기화 되어 있다.
<br />
<br />
### **push** 
> size 변수 번째의 배열의 칸에 변수를 저장하고, size변수를 1 증가시킨다
>     
	stack[size] = v;
    size += 1;


### **pop** 
> size 번째 변수를 삭제하는 연산이므로 
>
    stack[size-1] = 0; //size번째 변수를 초기화 하고
    size -= 1; //총 변수의 갯수(size변수)를 1 감소
<br />
<br />


# **스택을 사용하는 문제의 유형**
```
1. 괄호 문제
2. 쇠막대기 문제
3. 에디터 문제
```


### **1.괄호 문제**
-> 여는 괄호와 닫는 괄호의 쌍이 올바른지 판단하는 문제

닫는 괄호와 짝이 맞는 여는 괄호는 
```
1) 왼쪽에 있어야 하며
2) 아직 짝이 맞지 않아야 하며
3) 가장 오른쪽에 있는 괄호이다
```
> -> 시간복잡도: O(N^2)
>
>(왜냐하면 여는 괄호의 경우는 그냥 넘어가니 O(1)이고<br />
>닫는 괄호는 worst case의 경우 왼쪽의 모든 괄호를 봐야 하므로 O(N)<br />
>괄호는 총 N개 이므로<br />
>시간복잡도는 O(N^2)이다)

#### **스택을 활용**
```
1) 왼 -> 오 방향으로 검사
2)여는 괄호를 스택에 넣는다
3)그 결과 닫는 괄호가 나왔을때 짝이 맞는 가장 오른쪽에 있는 괄호는 스택의 top에 있는 여는 괄호이다
```
> -> 시간복잡도: O(1)<br />
>
> (왜냐하면 닫는 괄호가 나왔을때 짝이 맞는 여는 괄호가 항상 스택의 top에 위치하므로<br />
> 시간복잡도는 O(1)이다)

<br />
여는 괄호는 계속 스택에 push<br />
닫는 괄호가 나온 경우 여는 괄호를 pop<br />
<br />

만약 모든 문자에 검사를 완료했는데 짝이 없는 닫는 괄호가 있거나 여는 괄호가 스택에 남아있으면 올바르지 못한 괄호 문자열이다!

또 이때 스택에는 여는 괄호밖에 들어가지 않음! <br />
그러므로 우리가 관심을 가져야 하는 것은 스택에 어떤게 들어있는가가 아닌 스택에 들어있는 데이터의 갯수임!!!

즉 스택에 몇개의 여는 괄호가 들어갔는지를 cnt라는 변수로 두어 cnt 변수의 값을 가지고 문제를 푸는 경우도 있다

```
코드>
//문자열 s가 올바르면 “YES” 아니면 “NO”를 리턴하는 함수
string valid(string s) { 
    int cnt = 0;
    for (int i=0; i<s.size(); i++) {
        if (s[i] == ‘(‘) {
            cnt += 1;
        } else {
            cnt -= 1;
        }
        if ( cnt < 0 ) { //문자열이 끝나지 않았는데 '닫는 괄호수’ > ‘여는 괄호수’인 경우
            return “NO”;
        }
    }
    if ( cnt == 0 ) //문자열이 끝나고 ‘닫는 괄호수’ == ‘여는 괄호수’인 경우
        return “YES”;
    } else { //문자열이 끝났지만 ‘닫는 괄호수’ != ‘여는 괄호수’인 경우
        return “NO”;
    }
}
```
<br />
<br />

### **2.쇠막대기 문제**
-> 레이져는 여는 괄호와 닫는 괄호의 연속된 쌍 “()”으로 표현하고 쇠막대기의 왼쪽 끝은 여는 괄호 “(“, 오른쪽 끝은 닫는 괄호 “)”로 포현하여 레이져가 쇠막대기를 나눈후 쇠막대기의 총 개수를 묻는 문제

이 문제는 여는 괄호와 닫는 괄호가 인접해 있는지 아닌지에 대해 의미가 다르므로 스택에 여는 괄호의 index 번호(몇 번째 변수인지)를 저장

만약 닫는 괄호가 나왔는데 스택의 top 즉 가장 최근에 저장된 여는 괄호와 index 번호 차이가 1이라면 여는 괄호와 닫는 괄호가 연달아 나왔다는 것을 의미하고 이는 레이저를 의미한다

닫는 괄호가 나왔는데 스택의 top과 index 차이가 1보다 크다면 그것은 쇠막대기의 끝을 의미한다

#### **스택을 활용**
```
1)여는 괄호의 index를 스택에 저장
2)닫는 괄호가 나왔으면 스택으l top과 비교하여 index 차이가 1인지 본다.
  1이면 레이져 이므로 그동안 저장된? 쇠막대기 갯수 만큼의 새로운 쇠막대기가 나온다.
  즉 sum에 스택.size()를 더한다.
  만약 1이 아니면 쇠막대기 하나가 끝난 것이므로 sum에 1을 더한다
3)계속 그 과정을 반복하며 문자열이 끝날떼까지 반복한다.
```

```
코드>
int n = a.size();
stack<int> s;
int and = 0;
for (int i=0; i<n; i++) {
    if (a[i] == ‘(‘) {
        s.push(i); //여는 괄호 일 경우 index를 스택에 저장
    } else {
        if (s.top()+1 == i ) { //여는 괄호와 닫는 괄호가 index 1 차이 날 경우 -> 레이져
            s.pop(); //레이져의 ‘(‘를 제거하고
            ans += s.size(); //저장되어 있던 쇠막대기의 갯수만큼 새로운 쇠막대기가 생기므로 저장되어 있는 데이터의 수(s.size() )만큼 더한다
        } else { //여는 괄호와 닫는 괄호의 index 차이가 1이 아닐 경우 -> 쇠막대의 끝인 경우
            s.pop(); //끝난 쇠막대의 ‘(‘를 제거하고
            ans += 1; //끝난 쇠막대의 갯수를 추가
        }
    }
}
cout << ans << ‘\n’;
```

20:41까지 들음


















