**20191118 알고리즘 인강 3강<다이나믹 프로그래밍(문제풀이3 마무리)>**

### boj2579 문제( 계단 오르기 문제)
> 계단 오르는데는 다음과 같은 규칙 있음<br/><br/>
1.계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다.<br/>
(즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다)<br/><br/>
2.연속된 세 개의 계단을 모두 밟아서는 안된다. 단, 시작점은 계단에 포함되지 않는다.<br/><br/>
3.마지막 도착 계단은 반드시 밟아야 한다.<br/>
그리고 각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최대값을 구하는 문제.<br/>

<br/>
<br/>

**sol1) 2차원 배열 사용해서 푸는 법** <br/>
<br/>
`D[i][j]를 "i번째 계단에 올라갔을 때 최대 점수. 그리고 i번째 계단은 j개 연속해서 올라간 계단”`이라고 정의하면<br/>
D[i][0], D[i][1], D[i][2] 이렇게 세가지 경우가 올 수 있다.<br/>
<br/>

1) `D[i][0]` - i번째 계단이 0번째 올라갔을 때<br/>
->말이 안됨. i번째 계단을 밟았는데 0번째라는게<br/>
->경우에서 제외.<br/>
<br/>

2) `D[i][1]` - i번째 계단이 1번째 올라갔을 때<br/>
i번째 계단이 1번째 올라갔다고 하면,<br/>
그 직전 계단인 i-1번째 계단은 올라가지 말아야 하고<br/>
그 전 계단인 i-2번째 계단은 무조건 밟아야 한다.(다음 계단을 밟거나, 다음다음 계단을 밟아야 함)<br/><br/>
그럼 그 i-2번재 계단에서는 D[i-2][1], D[i-2][2]의 두가지 경우가 있고<br/>
i번째 밟은 계단을 추가해야하니<br/>
`D[i][1] = max(D[i-2][1], D[i-2][2]) + A[i];`<br/>
가 된다. <br/>
<br/>

3) `D[i][2]` - i번째 계단이 2번째 올라갔을 때<br/>
i번째 계단이 2번째 올라갔다고 하면,<br/>
그 직전 계단인 i-1번째 계단은 1번째로 올라가야 한다.<br/><br/>
그럼 i-2번째 계단에서 시작을 해서 <br/>
i-2 -> i-1 -> i 이렇게 연속으로 두번 올라가야 함.<br/>
그럼 <br/>
`D[i][2] = D[i-1][1] + A[i];`<br/>
가 된다.<br/>
<br/>
그래서 결과적으로 우리가 원하는 값은 `D[N][1]과  D[N][2] 두 값 중 큰 값`이다.<br/><br/>


```
코드>
d[1][1] = a[1];
for (int i=2; i<=n; i++) {
    d[i][2] = d[i-1][1] + a[i];
    d[i][1] = max(d[i-2][1], d[i-2][2]) + a[i];
}
```

<br/>
<br/>
<br/>

**sol2) 1차원 배열 사용해서 푸는 법**<br/>
2차원 배열에서 생각했던 경우를 고려해서 1차원 배열을쓰며 풀면 된다.(like 
[포도주 시식문제](https://github.com/zwonlala/TIL/blob/master/191113.md), 
[이친수 문제](https://github.com/zwonlala/TIL/blob/master/191112.md))<br/>
<br/>

`D[i]를 "i번째 계단에 올라갔을때, 최대 점수"`라고 정의하면<br/>


1) 1개 연속 -> i-1번째 계단은 밟으면 안됨.<br/>
    i-2번째 계단은 반드시 밟았어야 함<br/>
    `D[i-2] + A[i]`<br/>
    라는 값이 나오고<br/>
<br/>

2) 2개 연속 -> i-1번째 계단을 밟고, i-2번째 계단은 밟으면 안됨<br/>
    i-3번째 계단은 반드시 밟았어야 함<br/>
    `D[i-3] + A[i-1] + A[i]`<br/>
    라는 값이 나옴.<br/>
<br/>

```
코드>
d[1] = a[1];
d[2] = a[1]+a[2];
for (int i=3; i<=n; i++) {
    d[i] = max(d[i-2]+a[i], d[i-3]+a[i]+a[i-1]);
}
```


<br/>
<br/>
<br/>
<br/>
