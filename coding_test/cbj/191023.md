**20191023 알고리즘 인강 2강<자료구조1(스택 part ~)>**

...<br />
To be continued<br />
…


# **스택을 사용하는 문제의 유형**
```
1. 괄호 문제
2. 쇠막대기 문제
3. 에디터 문제
```
<br />

### **3. 에디터 문제**
-> 커서는 문장 맨 앞, 맨 뒤, 문장 중간에 임의의 곳에 올 수 있음
```
L : 커서를 왼쪽으로 한 칸 옮김
D : 커서를 오른쪽으로 한 칸 옮김
B : 커서 왼쪽에 있는 문자를 삭제함 
P$ : $라는 문자를 커서 오른쪽에 추가. 그후 커서는 $ 오른쪽에 위치
```

이 문제에서 중요 한 것은 N 제한이다!!

[https://www.acmicpc.net/problem/1406](url) <br/>
-> 초기에 입력되어 있는 문자열은 길이기 10만을 넘지 않고 명령의 갯수는 50만개를 넘지 않음 <br />
->> 문자열의 길이는 최대 60만이 될 수 있음 <br /><br />

하지만 각 연산 별 시간 복잡도를 보면

```
L : 커서를 왼쪽으로 한 칸 옮김 O(1)
D : 커서를 오른쪽으로 한 칸 옮김 O(1)
B : 커서 왼쪽에 있는 문자를 삭제함 O(N)
(왜냐하면 배열 내 이동이 최대 n 회 일어날 수 있기때문)
P$ : $라는 문자를 커서 오른쪽에 추가. 그후 커서는 $ 오른쪽에 위치 O(N)
(왜냐하면 배열 내 이동이 최대 n 회 일어날 수 있기때문)
```

즉 최종 시간복잡도는 O(N^2)이고 <br/>
입력이 60만이니 <br/>
3600억이 나와 문제를 풀 수 없게됨(1역==1초 니깐, 한시간 걸리는 거임…;) <br/>

따라서 좀 더 효율적으로 문제를 풀어야 함!!!
<br/><br/><br/>



생각해보면 커서를 기준으로 왼쪽 문자열 스택과 오른쪽 문자열 스택을 만들 수 있음
그리고 각 명령어가 각 스택에 어떤 의미인지 생각해봐야 함!

```
1. L : 커서를 왼쪽으로 한 칸 옮김
커서를 왼쪽으로 한 칸 옮긴다는 말은
왼쪽 스택에 가장 위에 있는 데이터를 오른쪽 스택으로 옮긴다는 말과 같다
즉 왼쪽 스택을 pop() 하고 그 값을 오른쪽 스택에 push()하는 것이다
위 연산의 시간복잡도는 O(1)

2. D : 커서를 오른쪽으로 한 칸 옮김
커서를 오른쪽으로 한 칸 옮기는 것은 위 1번과 동일하고 연산의 방향만 다름
즉 오른쪽 스택을 pop()하고 그 값을 왼쪽 스택에 push()함
시간복잡도는 동일하게 O(1)

3. B : 커서 왼쪽에 있는 문자를 삭제함 
커서 왼쪽에 있는 문자를 삭제하는 것은
왼쪽 스택에 가장 위에 있는 데이터를 pop()한 것
위 연산의 시간복잡도는 O(1)

4. P $ : $라는 문자를 커서 오른쪽에 추가. 그후 커서는 $ 오른쪽에 위치
문자를 커서 오른쪽에 추가하는 것은
왼쪽 스택에 $를 push()한 것
위 연산의 시간복잡도는 O(1)
```
<br/>
즉 모든 명령어가 O(1)이므로 이제 이 문제는 O(N)으로 풀 수 있다.<br/>
입력이 60만이니 충분히 풀 수 있는 문제이다<br/>
<br/>

그리고 문제의 결과값이 모든 명령어를 수행 한 후에 최종 문자열을 출력하는 것인데<br/>
모든 명령어를 수행한 후에 각 스택별로 pop()을 해서 출력하면 <br/>
왼쪽 스택은 역순으로 오른쪽 스택은 정순으로 출력되는 상황이 발생<br/>
<br/>

그러므로 왼쪽 스탭을 모두 pop()하여 오른쪽 스택에 push()하고 오른쪽 스택을 pop()하면 문제가 원하는 대로 잘 출력할 수 있다


```
코드>
char a [600000];
int main () {
    scanf (“%s”, a);
    stack<char> left, right;
    int n = strlen (a);

    for ( int i=0; i<n; i++ ) {
        left.push( a[i] );
    }
    int m;
    scanf (“%c”, &m);
    while ( m— ) {
        char what;
        scanf(“ %c”, &what);
        
        if (what == ‘L’) {
            if ( ! left.empty() ) {
                right.push( left.top() );
                left.pop();
            }
        } ...
        중략
        ...
```
<br/>
<br/>

## 스택의 특징

>### 가장 가까운 것을 O(1)만에 찾을 수 있다!<br/>
<br/>
지금까지 푼 괄호 문제, 쇠막대기 문제, 에디터 문제 모두 기준점으로부터 가장 가까운 것 의미가 있기 때문에 스택을 활용해서 풀 수 있었음.
<br/>
<br/>
<br/>
<br/>
















