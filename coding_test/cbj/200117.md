**20200117 알고리즘 인강 3강<다이나믹 프로그래밍(문제풀이4 마무리)>**

### boj1699 문제 (제곱수의 합 문제)
> 자연수 N을 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있는데, 그 때 항의 최소갯수를 구하는 문제

1, 2, 3 더하기 문제와 유사!<br/>
(단지 이 문제는 1, 2, 3 말고도 올 수 있는 수가 1^2, 2^2, … 이다는 점!)<br/>
<br/>
`[]+ []+ … + []= N` 일때,<br/>
맨 마지막에 올 수 있는 수는 1^2, 2^2, … 이고 이걸 `i^2`라고 하면<br/>

앞에 올 수 있는 수는(맨 마지막 수 제외한 수들의 합) `N - i^2`이고, <br/>

이때 필요한 항의 갯수는 `D[N - i^2]`이다.<br/>

그래서 N 번째 항의 점화식은 `D[N - i^2] + 1` 이고, 우리가 구하고 싶은 값은 `min(D[N - i^2] + 1)` 이다!<br/>
<br/>
이때 i의 범위에 대해 고민해보면, i^2 <= N이고 즉 `i <= '루트N’`이다<br/>
> 시간복잡도 : 총 N개의 칸을 채워야 하는데, 한개의 칸을 채우기 위해서는 i번 즉 루트 N 번 만큼 돌아야 한다.<br/>
즉, 시간복잡도는 O(N루트N)이다!<br/>
<br/>

```
코드>
for (int i=1; i<= n; i++) {
    d[i] = i; //가장 큰 경우가 1^2 N개로 정수 N을 표현하는 경우
    for (int j=1; j*j <= i; j++) {
        if (d[i] > d[i-j*j]+1) {
            d[i] = d[i-j*j] + 1;
        }
    }
}
```



<br/>
<br/>
<br/>
<br/>



### boj2133 문제(타일 채우기 문제)
>3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구하여라
<br/>

`D[n]`을 `3*N을 채우는 방법의 수`라고 정의하고, 마지막에 올 수 있는 경우의 수를 생각해보면,<br/>
<br/>

3*2 타일의 경우에는 3가지가 있고<br/>

3*4 타일의 경우에는 2가지가 있고,<br/>

3*6 타일의 경우에는 2가지가 있고,<br/>

계속 경우의 수가 2개씩 늘어난다.<br/>


그래서 점화식을 구해보면<br/>

`D[N] = 3*D[N-2] + 2*D[N-4] + 2*D[N-6] + …`
이렇게 풀 수 있다.<br/>



<br/>
<br/>
<br/>
<br/>



### boj9461 문제(파도반 수열 문제)
> 삼각형이 나선 모양으로 있을 때, 파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이임.<br/>
P(1) ~ P(10)은<br/>
1, 1, 1, 2, 2, 3, 4, 5, 7, 9일 때,<br/>
N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하라.


그림을 잘 보면 규칙이 보인다.<br/>
<br/>
12가 나오는 것은 9 + 3 이고<br/>
9가 나오는 것은 7 + 2 이다.<br/>
<br/>

즉 점화식 `D[i]`는<br/>
`D[i] = D[i-1] + D[i-5]`<br/>

문제에 그림이 있는 경우에는 그림을 잘 활용하면 문제를 풀 수 있다.<br/>
또 다른 점화식을 찾아보면, <br/>
<br/>
`D[i] = D[i-2] + D[i-3]`<br/>
<br/>
가 나온다.<br/>



<br/>
<br/>
<br/>
<br/>



### boj2225 문제(합분해 문제)
> 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 문제

일단 `D[k][N]`을 `정수 k 개를 더해서 합이 N이 되는 경우의 수`라고 하면<br/>
<br/>
`[]+ []+ []+ … + []+ []+ []= N` 이고, 왼쪽 []의 갯수는 `k`개 이고<br/>
위의 경우는 `D[k][N]`이다.<br/>
<br/>

맨 마지막 []를 `L`이라고 가정하면,<br/>
`[]+ []+ []+ … + []+ []+ L = N` 이고 좌변에 `L`을 빼면,<br/>
`[]+ []+ []+ … + []+ [] = N - L`이고,  왼쪽 []의 갯수는 `k-1`개 이다.<br/>
<br/>
즉, 위의 경우는 `D[k-1][N-L]`을 나타내는 경우의 수 인 것이다.<br/>
<br/>
이때, L의 범위를 살펴보면, `0 ≤ L ≤ N` 이고,<br/>

결과적으로 `D[k][N] 은 ∑ D[k-1][N-L] (단,  0 ≤ L ≤ N)` 인 것이다.

<br/>

> 시간복잡도 : 점화식의 시간복잡도를 계산해보면,<br/>
총 채워야 하는 칸의 갯수는 k * N개 이고,<br/>
한 칸을 채울 때 거치는 L의 범위는 0~N 이므로 <br/>
시간복잡도는 k*N^2 이다.<br/>
<br/>

```
코드>
d[0][0] = 1LL;
for ( int i = 1; i <= k; i++) {
    for ( int j = 0; j <= n; j++) {
        for ( int l = 0; l <= j; l++) {
            d[i][j] += d[i-1][j-l];
            d[i][j] %= mod;
        }
    }
} 
```

<br/>
<br/>

**sol2)** 이 문제를 다른 방법으로 풀어볼 수 있는데 공간을 줄여서 풀 수 있다.<br/>
<br/>
위 코드>를 보면, <br/>
`d[i][j] += d[i-1][j-l];`<br/>
즉 `d[i]~`를 채우는데 `d[i-1]~`이 필요하다.<br/>

즉,<br/>
`d[1]`을 만드는데는 `d[0]`이 사용되고,<br/>
`d[2]`을 만드는데는 `d[1]`이 사용되고,<br/>
`d[3]`을 만드는데는 `d[2]`이 사용되는 것이다.<br/>

이때 위 구조를 다르게 생각해보면 d[0]과 d[1]을 번갈아가며 사용하는 방식으로 생각해 볼 수 있다.<br/>

즉,<br/>
`d[1]`을 만드는데는 `d[0]`이 사용되고, 그 결과 `d[1]`을 d[1]에 저장하고,<br/>
`d[2]`을 만드는데는 `d[1]`이 사용되고, 그 결과 `d[2]`을 d[0]에 저장하고,<br/>
`d[3]`을 만드는데는 `d[2]`이 사용되고, 그 결과 `d[3]`을 d[1]에 저장하고,<br/>
이런식으로 번갈아가면서 저장을 해 나가아는 것이다.<br/>

이때, 변수를 사용하여 표현해 보면,<br/>
`d[i]~ -> d[i%2]~` <br/>
`d[i-1]~ -> d[1-(i%2)]~` <br/>
이렇게 나타낼 수 있다.<br/>
<br/>

**sol3)** 또 이 문제는 1차원 다이나믹으로 풀수도 있다.<br/>
<br/>

```
D[4][0] = D[3][0]
D[4][1] = D[3][0] + D[3][1]
D[4][2] = D[3][0] + D[3][1] + D[3][2]
D[4][3] = D[3][0] + D[3][1] + D[3][2] + D[3][3]
```
<br/>
위 식을 1차원으로 바꾸기 위해서는 앞에 있는 D[4]~와 D[3]~의 4와 3을 지우면 된다!<br/>

```
D[0] = D[0]
D[1] = D[0] + D[1]
D[2] = D[0] + D[1] + D[2]
D[3] = D[0] + D[1] + D[2] + D[3]
```

<br/>
그리고 위 식을 보면, 맨 마지막 항이 자기 자신을 더해주는? 부분이기 때문에 있을 필요가 없다 -> 삭제!<br/>

```
D[0] = 
D[1] = D[0] 
D[2] = D[0] + D[1] 
D[3] = D[0] + D[1] + D[2] 
```

<br/>

그리고 자기 자신에게 더하는 것이므로 `=` 을 `+=` 으로 바꿔주면 된다!<br/>

```
D[0] += 0
D[1] += D[0] 
D[2] += D[0] + D[1] 
D[3] += D[0] + D[1] + D[2] 
```

그리고 여기서 주의해야 할 점은,<br/>
for 문을 원래대로 `위 -> 아래`가 아닌 `아래 -> 위` 이렇게 돌려야 한다는 것이다.<br/>

(∵위에서 아래로 돌리면 두번째 D[1]+=D[0]을 수행하고 나면, <br/>
D[1]은 더이상 D[3][1]이 아니라 D[4][1]을 나타내게 되므로, 아래의 값이 틀리게 된다!)<br/>

```
코드>
d[0] = 1;
for ( int i = 1; i <= k; i++) {
    for ( int j = n; j >= 0; j—) {
        for ( int l = 1; l <= j; l++) {
            d[j] +=d[j-l];
            d[j] %= mod;
        }
    }
}
```



<br/>
<br/>
<br/>
<br/>



### boj2011 문제 (암호코드 문제)
> 어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하는 문제

<br/>

그래서 D[i]를 i번째 문자까지 해석했을 때, 나올 수 있는 해석의 가짓수 라고 정의하면,<br/>

i 번째 문자에 가능한 경우는 <br/>
* 1자리 암호 //0~9인 경우
* 2자리 암호 //10~26인 경우
이렇게 두가지만 존재한다.<br/>
<br/>

```
코드>
d[0] = 1; //길이가 0이면 해석할 수 있는 가짓수는 1가지 이다.

for ( int i = 1; i <= n; i++) {

    int x = s[i] - ‘0’; //1자리 암호로 해석하는 부분
    if (1 <= x && x <= 9) {
        d[i] = (d[i] + d[i-1]) % mod; //i-1 번째 까지 해석할 경우의 수 더해 줌.
    }

    if ( i == 1 ) continue; // i가 1이면 길이가 1 이므로 2자리 암호로 해석이 불가능! -> continue;

    if ( s[i-1] == ‘0’) continue; // i-1번째 수가 0이라면 2자리 암호로 해석이 불가능! -> continue;

    x = (s[i-1] - ‘0’) * 10 + (s[i] - ‘0’); // i-1 번째 수와 i 번째 수를 두 자리 수로 만들어 x에 저장한 다음.
    if (10 <= x && x <= 26) { //그 값 x에 저장된 값이 10과 26 사이이면
        d[i] = ( d[i] + d[i-2] ) % mod; // i-2 번째 까지 해석한 경우의 수 더해줌.
    }
}
```





<br/>
<br/>
<br/>
<br/>


to be continue...

<br/>
<br/>
<br/>
<br/>











