**20191112 알고리즘 인강 3강<다이나믹 프로그래밍(문제풀이2)>**

### boj2193 문제( 이친수 문제)
> 0과 1로만 이루어진 수를 이진수.<br/>
다음 조건을 만족하면 이친수라고 함.<br/>
1.이친수는 0으로 시작하지 않는다.<br/>
2.이친수에서는 1이 두번 연속으로 나타나지 않는다. 즉 부분 문자열로 “11”이 없다.<br/>
N 자리 이친수의 갯수를 구하는 문제.<br/>

### sol1)<br/>
즉 `D[N] = “N자리 이친수의 갯수”`로 하고 <br/>
N번째 자리에 올 수 있는 수는 0 또는 1 이므로, 0이 왔을 경우와 1이 왔을 경우를 나눠서 생각하면 됨.<br/>

**1) N 번째 자리에 0**<br/>
N번째 자리가 0이면 N-1 번째 자리는 0 또는 1이 올 수 있다.<br/>
`…[ 0 & 1 ] [ 0 ]` <br/>
-> 즉 N-1 자리의 이친수 뒤에 0을 붙이면 N자리 이친수가 된다.<br/>
-> 이 케이스의 갯수는 D[N-1]이 된다.<br/>

**2) N 번째 자리에 1**<br/>
N번째 자리가 1이면, 연속으로 2번 1이 올 수 없다는 조건에 따라 N-1번재 자리는 0이 와야한다.<br/>
그리고 0 앞에는 아무거나 올 수 있기 때문에<br/>
`…[ 0 & 1 ] [ 0 ] [ 1 ]`<br/>
-> 즉 이 경우는 N-2 자리의 이친수 뒤에 01을 붙인 경우라 볼 수 있다.<br/>
-> 이 케이스의 갯수는 D[N-2]가 된다.<br/>
<br/>
즉 `D[N] = D[N-1] + D[N-2]`가 된다.<br/>
<br/>


### sol2)<br/>
`D[i][j]를 "i자리 이친수의 갯수 중에서 j로 끝나는 것의 갯수"(j=0,1)`라고 하면,<br/>
<br/>
**1)N 번째 자리에 0**<br/>
N번째 자리가 0이면 N-1 번째 자리는 0 또는 1이 올 수 있으므로 <br/>
`D[N][0] = D[N-1][0] + D[N-1][1]`<br/>
<br/>
<br/>
**2)N 번째 자리에 1**<br/>
N번째 자리가 1이면, 연속으로 2번 1이 올 수 없다는 조건에 따라 N-1번재 자리는 0이 와야하므로<br/>
`D[N][1] = D[N-1][0]`<br/>
<br/>
그리고 정답은 `D[N][0] + D[N][1]`이다.<br/>




<br/>
<br/>
<br/>
<br/>




### boj10844 문제(쉬운 계단 수 문제)
> 인접한 자리의 차이가 1이 나는 수를 계단 수라고 함<br/>
길이가 0인 계단수는 없고, 계단 수는 0으로 시작 할 수 없다.<br/>
길이가 N인 계단수의 개수를 구하는 문제<br/>

`D[N][L]을 마지막 수가 L인 N자리 계단 수의 갯수`라고하면<br/>
N-1번째 자리에 올 수 있는 수는<br/>
`… [L-1] [L]`<br/>
`… [L+1] [L]`<br/>
이렇게 L-1, L+1 두가지가 있다.<br/>

즉 `D[N][L] = D[N-1][L-1] + D[N-1][L-1]`이라고 할 수있다. 이때 L의 범위는 1<= L <=8 이다.<br/>
그리고 위의 L의 범위에 속하지 않는 0과 9는<br/>
`D[N][0] = D[N-1][1]` <br/>
`D[N][9] = D[N-1][8]`<br/>
을 만족한다.<br/>

```c
코드>
for ( int i=1; i<=9; i++ ) d[1][i] = 1; //길이가 1인 경투
for ( int i=2; i<=n; i++ ) {
    for ( int j=0; j<=n; j++ ) {
        d[i][j] = 0;
        if (j-1 >= 0) d[i][j] += d[i-1][j-1]; // 0 예외처리
        if (j+1 <= 9) d[i][j] += d[i-1][j+1]; // 9 예외처리
        d[i][j] %= mod;
    }
}
long long ans = 0;
for (int i=0; i<=9; i++)  ans += d[n][i]; //D[N][0] 부터 D[N][9] 까지의 합이 원하는 결과이므로
ans %= mod;
```

<br/>
<br/>
<br/>
<br/>

### boj 11057문제(오르막 수 문제)
> 오르막 수는 수의 자리가 오름차순을 이루는 수를 말하고<br/>
인접한 수가 같아도 오름차순으로 친다.<br/>
수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 문제이다.<br/>
(이때 수는 0으로 시작할 수 있다.)<br/>

`D[N][L]을 N자리 오르막 수 중 마지막 수가 L인 수의 갯수`로 정의하면<br/>
N번째 자리에 L이 왔으므로<br/>
N-1 자리엔 0 ~ L의 수가 올 수 있다.<br/>
즉 `… [0~L] [L]` 이 꼴을 만족한다.<br/>

이때 0 ~ L 이 범위에 해당하는 수를 k로 정의 하면<br/>
`D[N][L] = 𝝨D[N-1][k] (0<=k<=L)`<br/>
이렇게 정리할 수 있다<br/>

```c
코드>
for ( int i=0; i<=9; i++ ) d[1][i] = 1; //0으로 시작할 수 있으므로
for ( int i=2; i<=n; i++ ) {
    for ( int j=0; j<=9; j++ ) {
        for ( int k=0; j<=j; k++) {
            d[i][j] += d[i-1][k];
            d[i][j] %= mod;
        }
    }
}
long long ans = 0;
for (int i=0; i<10; i++) ans += d[n][i]; // 0부터 9까지 올 수 있는 모든 수를 더함
ans %= mod;
```


<br/>
<br/>
<br/>
<br/>

### boj 9465문제(스티커 문제)
> 스티커가 2N개가 2 * N 모양으로 배치되어 있다.<br/>
스티커 한 장을 떼면 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없다.<br/>
스터커 각각에 붙은 점수의 합을 최대로 만드는 문제.<br/>
문제를 보면 스티커를 떼는 순서가 정해져 있지 않으므로 -> 우리가 스티커를 떼는 순서를 지정할 수 있다.<br/>

왼쪽부터 차례대로 스티커를 뜯는 문제로 가정하고 문제를 풀어보자.<br/>

이때 각 줄에 대한 상태의 경우의 수는 총 3가지가 있다.<br/>

`X`<br/>
`X`<br/>
즉 둘다 뜯지 않는 0번 경우와<br/>

`O`<br/>
`X`<br/>
즉 위에 스티커를 뜯는 1번 경우<br/>

`X`<br/>
`O`<br/>
그리고 아래 스티커를 뜯는 2번 경우 이렇게 세가지다.<br/>

`D[N][S]를 2 * N 스티커를 뜯는데 N 번째 줄의 상태가 S인 상황의 점수의 최대값`으로 정의하고<br/>
(이때 상태 S는 위의 0, 1, 2번 경우를 말함)<br/>

A[i][j]는 i 열 j 행의 스티커가 갖는 점수라고 정의하자.<br/>

D[N][S]를 보면<br/><br/>
**1) S가 0인 경우**<br/>
D[N][0]인 경우는 위 아래 모두 스티커를 뜯지 않은 상태이다. 그럼 N-1칸에는 0, 1, 2 상태가 다 올 수 있다.<br/>
즉, `D[N][0] = max(D[N-1][0], D[N-1][1], D[N-1][2])` 이다.<br/>

**2) S가 1인 경우**<br/>
D[N][1]인 경우는 위쪽 스티커만 뜯은 경우이다. 그럼 N-1칸에는 0, 2 상태가 올 수 있다.<br/>
즉, `D[N][1] = max(D[N-1][0], D[N-1][2]) + A[N][1]` 이다.<br/>

**3) S가 2인 경우**<br/>
D[N][2]인 경우는 아래쪽 스티커만 뜯은 경우이다. 그럼 N-1칸에는 0, 1 상태가 올 수 있다.<br/>
즉, `D[N][2] = max(D[N-1][0], D[N-1][2]) + A[N][2]` 이다.<br/>

그리고 문제가 원하는 스티커 점수의 최대값은 `max(D[N][0], D[N][1], D[N][2])`이다.<br/>


<br/>
<br/>
<br/>
<br/>