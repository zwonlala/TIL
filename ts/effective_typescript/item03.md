
# item 3 "코드 생성과 타입이 관계없음을 이해하기"


TS 컴파일러는 두 가지 역할을 수행함

### 1. 최신 TS / JS 를 브라우저에서 동작할 수 있도록 구버젼의 JS로 트랜스파일(transpile) 함

- **트랜스파일(transpile)**: _**번역(translate)**_ + _**컴파일(compile)**_  
소스 코드를 동일한 동작을 하는 다른 형태의 소스 코드(다른 버젼이나 다른 언어)로 변환하는 행위를 의미   
결과물이 여전히 컴파일되어야 하는 소스 코드이기 때문에 컴파일(compile)과는 다르게 부름!


### 2. 코드의 타입 오류를 체크함


주의해야할 게 위 두가지 내용이 서로 완벽히 독립적이라는 것!

=> TS 가 JS 로 변환될 때 코드 내의 타입에는 영향을 주지 않음

=> 그리고 그 JS의 실행 시점에도 타입은 영향을 미치지 않음

&nbsp;


TS 컴파일러가 수행하는 두가지 역할을 생각해보면,

- TS 가 할 수 있는 일
- TS 가 할 수 없는 일

을 짐작할 수 있음


&nbsp;
&nbsp;


## 타입 오류가 있는 코드도 컴파일이 가능함

컴파일은 "타입 체크"와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능.

> "타입 체크"와 "컴파일"이 동시에 일어나는 C 나 JAVA 와 같은 언어를 사용하던 사람이라면 이런 상황이 어색하게 느껴질 것

TS 오류는 C 나 JAVA 와 같은 언어들의 경고(Warning)와 비슷

문제가 될 만한 부분들을 알려주지만, 그렇다고 빌드를 멈추지는 않음

&nbsp;

만약, 오류가 있을때 컴파일하지 않으려면, tsconfig.json 에 **`noEmitOnError`** 를 설정하면 됨

&nbsp;
&nbsp;


## 런타임에는 타입 체크가 불가능합니다.

잘 이해안됨.

송지원 다시 정리하기.

&nbsp;
&nbsp;


## 타입 연산은 런타임에 영향을 주지 않습니다.

잘 이해안됨.

송지원 다시 정리하기.

&nbsp;
&nbsp;


## 런타임 타입은 선언된 타입과 다를 수 있습니다.

잘 이해안됨.

송지원 다시 정리하기.

&nbsp;
&nbsp;


## TS 타입으로는 함수를 오버로드 할 수 없습니다.

잘 이해안됨.

송지원 다시 정리하기.

&nbsp;
&nbsp;


## TS 타입은 런타임 성능에 영향을 주지 않습니다.

잘 이해안됨.

송지원 다시 정리하기.

&nbsp;
&nbsp;
&nbsp;
&nbsp;
