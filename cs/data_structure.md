자료구조

-ADT (추상적 자료구조) : 

-스택과 큐
	스택은 선입후출(FILO) 구조 -> 함수 호출 스택,(함수를 호출하면 호출한 함수로 실행흐름이 넘어가는데, 해당 함수가 끝난 후에 해당 함수를 호출했던 곳으로 돌아갈때 사용(활성 레코드/Activation Record를 쌓는다 말함, 활성 레코드에 돌아가야 할 주소와 현재 환성 레코드의 크기에 대한 정보가 포함되어 있음. 활성 레코드를 추가할때 스택에 푸쉬하고, 함수를 종료할때 팝함)

배열로 구현할 수 있다. 큰 배열에 스택의 가장 위 인덱스를 가리키는 변수를 두고, 푸쉬하면 해당 변수를 ++, 팝하면 해당 변수를 --; 하여 연산함!



	큐는 선입선출(FIFO) 구조 -> 메세지 큐(scanf 같은 동기 입력함수를 실행하면, 사용자의 입력을 기다리고, 터미널에 입력하면 입력 수행됨. 이건 OS가 키보드에서 생긴 이벤트를 프로세스의 이벤트 큐에 넣어주기 때문에 동작. 메세지 큐는 프로세스간 통신을 비롯한 여러곳에서 사용!)

배열로 구현할 수 있다. 큰 배열에 큐의 프론트와 리어의 인덱스를 저장하는 변수를 두고, 푸쉬하면 리어를 ++; 팝하면 프론트를 ++;하여 저장할 수 있다.

	+a 덱 – 앞 뒤로 삽입과 삭제를 가능하게 한 자구

- 배열과 연결리스트
배열 : 메모리 상에 저장되어있는 데이터가 순차적으로 저장되어 있다 
-> 원하는 인덱스를 오(1) 만에 접근할 수 있다.
-> 반면 중간 데이터의 추가나 삭제가 일어나면, 해당 원소 뒤에 있는 원소들을 모두 한칸씩 땡기거나 밀어야 하기때문에 O(n) 만큼의 연산이 필요하여 불리.

연결리스트 : 노드라는 것으로 이루어진 자구인데, 노드에는 정보를 저장하는 부분과 다른 노드의 주소값을 저장하는 부분이 있어 다음 노드의 주소값을 저장하는 것으로 데이터들의 순서를 보존? 한다.
->배열의 새로운 원소를 추가/삭제하기 힘들다는 점에 비해 연결리스트는 추가/삭제할 위치에 도달하면 해당 연산을 오(1)만에 해낼 수있다. (해당 위치까지 가는건 오(N) 필요)
->그것과 달리 원하는 인덱스까지 가기 위해서는 root? 시작 노드 부터 넥스트를 통해 다음 노드로 순차적으로 이동하므로 원하는 인덱스에 접근하기 위해서는 오(N) 필요
ex) 파일 시스템의 가용 디스크 블록을 연결 리스트로 관
ex)B-tree에서도 단말 노드 간의 연결을 위해 연결 리스트가 사용됨.

링크드 리스트의 원소의 삽입 순서
A -> B -> C -> D 순서인데, B와 C 사이에 N을 삽입)
1)비의 위치까지 이동,
2)엔의 넥스트에 비의 넥스트값(씨 주소) 저장
3)비의 넥스트에 엔의 주소 저장
끝

링크드 리스트의 원소의 삭제 순서
A -> B -> C -> D 순서인데, C 삭제)
1)비의 위치까지 이동
2)비의 넥스트(씨)의 주소 템프변수에 저장
3)템프의 넥스트(디)의 주소를 비의 넥스트에 저장
4)템프(씨) 주소 프리

더블 링크드 리스트의 원소의 삽입 순서
A -> B -> C -> D 순서인데, B와 C 사이에 N을 삽입)
1)비의 위치까지 이동,
2)엔의 프리브에 비의 주소 저장
3)엔의 넥스트에 비의 넥스트의 주소(씨) 저장
4)비의 넥스트(씨)의 프리브에 엔 저장
5)비의 넥스트에 엔 저장
끝

더블 링크드 리스트의 원소의 삭제 순서
A -> B -> C -> D 순서인데, C 삭제)
1)비의 위치까지 이동
2)비의 넥스트(씨) 템프에 저장
3)비의 넥스트에 템프의 넥스트(디) 저장
4)템프의 넥스트(디)의 프리브에 비 저장
5)템프(씨) 프리


-트리 : connect component이면서 cycle이 존재하지 않는 특수한 그래프
노드로 이루어진 자료 구조
	1. 트리는 하나의 루트 노드를 가지고
	2. 루트 노드는 0개 이상의 자식 노드를 가지고 있고
	3. 그 자식 노드 또한 0개 이상의 자식 노드를 가지고 있고, 반복적으로 정의됨
-노드들과 노드들을 연결하는 간선(엣지)로 구성되어 있음
-트리에는 사이클이 존재할 수 없음
root : 부모가 없는 노드, 트리는 하나의 루트 노드만 가짐
internal(내부) node : 단말 노드가 아닌 노드
leaf(단말) node : 자식이 없는 노드
edge(간선) : 노드를 연결하는 선(link, branch)라고 부름 
sibling(형제) : 같은 부모를 가지는 노드

노드의 크기(size) : 자신을 포함한 모든 자손 노드의 개수
노드의 깊이(depth) : 루트에서 어떤 노드에 도달하기 위해 거처야 하는 간선의 수
노드의 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합(루트는 0)

노드의 차수(degree) : 하위 트리 개수 / 간선 수(각 노드가 가지는 가지의 수)
트리의 차수(degree of tree) : 트리의 최대 차수
트리의 높이(height) : 루트 노드에서 가장 깊숙히 있는 노드의 깊

트리의 사용 예시 : 검색!
이진 검색은 O(logN)의 시간복잡도를 보임. (검색을 해나갈때, 고려대상을 1/2씩 줄여나가기 때문)
검색을 빠르게 수행하기 위해서는 트리의 깊이를 최대한 키우지 말기! -> 깊이가 깊어질수록 비교를 수행해야하는 횟수가 늘어남.

트리의 종류 : 


이진 트리(Binary tree)
	각 노드가 최대 두개의 자식을 갖는 트리
	이진 트리 순회 : 중위 순회(왼->노드->오), 전위 순회(노드->왼->오), 후위 순회(왼->오->노드)
	장점 : 룩업연산(트리에 있는 특정 노드의 위치를 알아내는 연산)을 빠르고 간단하게 처리할 수 있다



이진 탐색 트리(Binary Search Tree)
	모든 노드가 아래와 같은 특징을 따르는 속성이 있는 이진 트리
	왼쪽 모든 자식들 <= N < 모든 오른 자식들(모든 노드 N에 대해서 반드시 참)

 
만약 이진 검색트리가 균형검색 이진 트리라면 룩업연산의 실행시간은 O(logN)이다
만약 데이터가 한쪽으로 쏠려 있는 경우라면, 룩업연산의 실행시간은 O(N)

삽입 : 현재 노드보다 작으면 왼쪽, 크면 오른쪽에 위치시킨다는 기본 원칙만 지키면 된다.
이진 탐색 트리를 순회할때는 중위 순회 방식을 사용한다.

삭제 : 
1) 삭제할 노드가 리프 노드인 경우 : 그냥 삭제
2) 삭제할 노드의 자식이 하나인 경우 : 삭제하고자 할 노드의 부모가 삭제하고자 하는 노드의 자식을 가리키게 한다
3) 삭제한 노드의 자식이 두개 인 경우 : 삭제하고자 하는 노드의 오른쪽 자식 노드 중 가장 작은 노드를 삭제할 노트 위치에 놓는다


B-Tree : 이진 트리가 자식 노드가 최대 2개인 노드를 말하는 것이라면, B-Tree는 자식 노드의 개수가 2개 이상인 트리를 말함. 또한 노드 내 데이터가 1개 이상일 수 있음.

B-Tree 성립조건 :
1)노드의 데이터의 수가 n개 라면, 자식 노드의 수는 n+1개 입니다
2)노드의 데이터는 무조건 정렬된 상태여야 합니다.
3)노드의 자식 노드의 데이터들은 노드 데이터를 기준으로 데이터보다 작은 값은 왼쪽 서브트리에 큰 값들은 오른쪽 서브트리에 이루어져야 함.
4)루트 노드가 자식을 가지고 있다면, 2개 이상의 자식 노드를 가져야 함.
5) 루트 노드를 제외한 모든 노드는 적어도 M/2개의 데이터를 가지고 있어야 함???
6) 리프 노드로 가는 경로의 길이는 모두 같아야 합니다.(리프 노드는 모두 같은 레벨에 있어야 합니다)

힙: 힙은 완전이진 트리(Complete Binay Tree)이며 최솟값이나 최댓값을 빠르게 찾아내기 위한 자료구조로 활용됨. 신기한 방법으로 노드를 추가하거나 삭제할때마다 일정한 처리를 함으로써 루트 노드는 항상 최댓값이거나 최솟값이 되도록 한다.
이 방식을 이용하여 우선 순위 큐를 구현할때 힙을 이용하기도 하고, 힙 정렬 또한 힙 구조 이용한 정렬방식임.

최소 신장 트리(Minimum Spanning Tree) : 네트워크 망을 그래프 개념으로 볼때, 최소 신장 트리를 만들면, 최사한 각 네트워크 노드들이 모두 연결되어 있음을 보장함.


- 그래프 : 그래프는 꼭지점(Vertex, Node)들과 그 사이를 잇는 변(Edge)들로 구성된 자료구조

변의 방향성을 가지는지에 따라 유향 그래프 또는 무향 그래프로 분류,

그래프를 자료구조로 표현하는 방법도 여러가지다.
1)2차원 배열을 사용하여 인접행렬로 표현

2)각 정점마다 연결된 정점을 리스트로 표현하는 인접 리스트로 표현

3)변들을 리스트로 가지는 엣지 리스트로 표현하기 도 함

-> 한 노드에서 다른 노드까지의 이동 비용을 변의 가중치를 두고 최단 거리 경로를 구하는 문제 : 다익스트라 알고리즘(네트워크 망에서 패킷을 빠르게 이동하기 위한 라우팅 알고리즘)


-해시 테이블
: 해시 테이블은 해시 함수로 인덱스를 결정하여, O(1)의 시간복잡도로 원하는 데이터를 찾기 위해 고안된 자료구조

어떤 값을 해시 함수를 거져 나온 결과 값을 인덱스로 하여 해당 인덱스의 버킷으로 바로 접근하는 아디이더임.

당연히 해시 함수가 고르고(uniform) 무작우이하게(random) 값을 해기해야 함.
