**20200206 알고리즘 인강 4강<수학 1>**


### 1. 나머지 연산
### 2. 최대공약수
### 3. 최소공배수
### 4. 진법 변환
### 5. 소수
 - 에라토스테네스의 체
 - 골드바흐의 추측
### 6. 소인수분해
### 7. 펙토리얼


<br/>
<br/>
<br/>
<br/>


# 1.나머지 연산

- `(A+B)%C = ((A%C) + (B%C))%C`라는 사실<br/>

- `DP`를 풀 때 많이 사용..!<br/>
(∵ 경우의 수를 구하는 문제 일 때, 경우의 수가 너무 커서 문제에서 MOD로 나눈 나머지를 출력하라고 나옴.)<br/>
- "MOD 로 나눈 나머지를 출력하라”라고 문제에서 나와 있으면<br/>
 최종 결과를 구한 다음에 MOD로 나눈 나머지를 구하는 것이 아니라<br/>
 중간중간 과정에서 MOD 로 나눠서 구하면 된다.<br/>
<br/>

```
- (A + B) mod M = ( (A mod M) + (B mod M) ) mod M
- 뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에,
  (A - B) mod M = ( (A mod M) - (B mod M) + M ) mod M
- (A × B) mod M = ( (A mod M) × (B mod M) ) mod M
- 나누기의 경우에는 성립하지 않음.(Modular Inverse를 구해야 함.)
```


<br/>
<br/>
<br/>
<br/>


# 2.최대공약수(Great Common Division)

* 최대 공약수는 줄여서 GCD라고 함
* 두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수
* 최대공약수를 구하는 가장 쉬운(가장 고민안한) 방법은 `2`부터 `min(A, B)`까지 모든 정수로 나누어 보는 방법이다.
* 최대공약수가 1인 두 수를 `서로소(Comprime)`라고 한다.

<br/>
<br/>

```
코드> 가장 쉬운(가장 고민 안한) 방법

int g = 1;
for ( int i = 2; i <= min(A, B); i++) {
    if (A%i == 0 && B %i == 0) {
        g = i;
    }
}
```
> 시간복잡도 : O(N)

<br/>
<br/>

* 위 방법보다 빠른 방법이 있다.
* `유클리드 호제법(Euclidean Algorithm)`을 이용하는 방법

	```
	- a를 b로 나눈 나머지가 r이라고 할때,(즉, r = a % b)

	- GCD(a, b) = GCD(b, r) 과 같음 
	(∵ r은 b보다 작고, 나누어 떨어지지 않는 나머지 이므로)
	- r이 0이면, 그 때 b가 최대공약수 이다.
	
	- ex) GCD(24, 16) = GCD(16, 8) = GCD(8, 0) = 8 
	
	- 유클리드 알고리즘의 형태가 함수처럼 생겼고, 함수인데 값을 리턴하는 것 처럼 생겼다
	=> 재귀처럼 쓸 수 있다.
	```
<br/>
<br/>

```
코드> 재귀형식으로 짠 유클리드 호제법

int gcd (int a, int b) {
    if (b == 0) { //최대공약수를 구한 경우가 b가 0인 경우이므로!
        return a;
    } else {
        return gcd(b, a%b); // GCD(a, b) = GCD(b, a%b)
    }
}
```

<br/>
<br/>

```
코드> 재귀를 사용하지 않고 짠 유클리드 호제법

int gcd (int a, int b) {
    while (b != 0) {
        int r = a%b;
        a = b;
        b = r;
    }
    return a;
}
```
<br/>
<br/>

* 유클리드 호제법을 구현할 때, a가 b보다 크면 a, b를 서로 SWAP하는 경우가 있는데, 그럴 필요가 없다<br/>
(∵ GCD(a, b)를 구할 때, a가 b보다 작으면 r인 a%b가 결국 다시 a가 되고,<br/>
 그 다음에는 GCD(b, a)를 구하게 되어 저절로 SWAP 된다!)<br/>
<br/>

* 세 수의 최대공약수를 구하는 경우에는, 
`GCD(a, b, c) = GCD( GCD(a, b), c)`<br/>
위와 같이 구할 수 있고, 위 방식은 N개의 수의 최대공약수를 구하는 경우에도 적용된다.


<br/>
<br/>
<br/>
<br/>


# 3.최소공배수(Least Common Multiple)

* 최소공배수는 줄여서 LCM이라고 한다
* 두수의 최소 공배수는 두 수의 공통된 배수 중에서 가장 작은 정수
* 최소공배수는 GCD를 활용하여 구할 수 있다
* 두 수 A와 B의 최대공약수를 G라고 했을 때, (즉, A = aG, B = bG, a와 b는 서로소)
* 최소공배수 L은 `L = A × B / G` (아빠는 엘지팬)
* 이 때 조심해야하는 것은 최대공약수 G는 범위가 있지만, 최소공배수 L은 범위가 없고 가장 큰 경우는 두 수를 곱한 A × B이다. 그래서 이때 만약, A와 B는 int의 범위 안에 있다고 해도, 최소공배수 L은 int의 범위를 벗어날 수 있다! <br/>
=> 범위를 체크해서 올바른 자료형을 쓰는 것이 중요하다..!

<br/>
<br/>

#### boj2609)
문제에서 주어진 A와 B의 범위가 10,000 이하의 자연수 이니,<br/>
최소공배수가 항상 A × B 즉, 1억 이내에 존재 <br/>
=> int 형 쓸 수 있다. 

```
코드>

#include <iostream>
using namespace std;

int gcd(int x, int y) {
    if (y == 0 ) return x;
    else return gcd(y, x%y);
}
int main() {
    int a, b;
    cin >> a >> b;
    int g = gcd(a, b);
    cout << g << ‘\n’ << a*b/g << '\n';
    return 0;
}
```


<br/>
<br/>
<br/>
<br/>


# 4.진법 변환

* 10진법 수 N을 B진법으로 바꾸려면, N이 0이 될 때까지 나머지를 계속해서 구하면 된다.

<br/>
<br/>

#### boj11005) 10진법 수 N을 B진법으로 바꾸어 출력하는 문제
```
코드>

#include <algorithm>
#include <iostream>
#include <string>

using namespace std;

int main() {
    int n, b;
    cin >> n >> b;
    string ans = “”;
    
    while (n > 0) {
        int r = n % b;
        if (r < 10) {
            ans += (char) (r + ‘0’);
        } else {
            ans += (char) (r - 10 + ‘A’);
        }
        n /= b;
    }
    reverse(ans.begin(), ans.end());
    cout << ans << ‘\n’;
    return 0;
}
```

<br/>
<br/>

* B진법 수 N을 10진수로 바꾸려면, B^k을 곱하면서 더해가면 된다.

#### boj2745) B진법 수 N을 10진법으로 바꾸는 문제

```
코드>

#include <iostream>
#include <string>

using namespace std;

int main() {
    int ans = 0;
    string s;
    int b;
    cin >> s >> b;
    for (int i = 0; i<s.size(); i++) {
        if (‘0’ <= s[i] && s[i] <= ‘9’) {
            ans = ans * b + (s[i] - ‘0’);
        } else {
            ans = ans * b + (s[i] - ‘A’ + 10);
        }
    }
    cout << ans << ‘\n’;
    return 0;
}
```

<br/>

#### boj1373) 2진수를 8진수로 바꾸는 문제
#### boj1212) 8진수를 2진수로 바꾸는 문제
#### boj2089) N을 -2진수로 바꾸는 문제
```
* 일반적인 진법 변환과 똑같이 하면 된다.
* 이때, 나머지가 음수가 되면 안된다는 점을 조심해서 구현해야 한다
* 2가지 케이스가 있는데
    * 양수 / -2
    * 음수 / -2
* 각각의 경우에서 양수가 2로 나누어 떨어지는 경우와
* 음수가 2로 나누어 떨어지는 경우로 나눌 수가 있다
```

<br/>

- 진법 변환
```
* A 진법을 B 진법으로 바꾸려면
* 'A 진법 -> 10 진법 -> B 진법' 의 과정을 거치면 된다.
```
#### boj11576) A 진법을 B 진법으로 바꾸는 문제


<br/>
<br/>
<br/>
<br/>


# 5.소수 

* 약수가 1과 자기 자신 밖에 없는 수
* N이 소수가 되려면, `2`보다 크거나 같고, `N-1` 보다 작거나 같은수로 나누어 떨어지면 안된다
* 어떤 수 N이 소수인지 아닌지 판별하려면 아래와 같은 코드를 사용하여 판별할 수 있다.

```
코드1> 2 ~ N-1 까지 나누는 코드

bool prime (int n) {
    if (n < 2 ) {
        return false;
    }
    for (int i = 2; i<= n-1; i++) {
        if (n % i == 0) {
            return false;
        } 
```
> 시간복잡도 : O(N)

<br/>
<br/>

* 위 코드보다 성능이 조금 더 향상된 코드도 있다.
* N이 소수가 되려면, `2`보다 크거나 같고, `N/2` 보다 작거나 같은 자연수로 나누어 떨어지면 안된다.<br/>
(∵ N의 약수 중에서 가장 큰 것이 `N/2`이고 그러므로 모든 약수는 `N/2` 보다 작거나 같기 때문)

```
코드2> 2 ~ N/2 까지 나누는 코드

bool prime (int n) {
    if (n < 2) {
        return false;
    }
    for (int i = 2; i <= n/2; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```
> 시간복잡도 : O(N) (∵ 상수 1/2는 무시되기 때문!)

<br/>
<br/>

* 위 방법은 첫 번째 방법보다 개선되긴 하였지만, 시간복잡도는 동일하다
* 가장 빠른 방법은 `2 ~ 루트 N`까지 나누어 보는 코드이다.
* N이 소수가 되려면, `2`보다 크거나 같고, `루트N` 보다 작거나 같은 자연수로 나누어 떨어지면 안된다
	```
    * ∵ N이 소수가 아니라면, 'N = a×b'로 나타낼 수 있다.(단, a < b)
    * 두 수 a와 b는 'a ≦루트 N' or 'b ≦ 루트 N'를 만족해야 한다. 
    * 그런데 위에서 a < b라고 했으니, a는 루트 N보다 작거나 같아야 한다.
    * 그래서 a의 범위는 '2 ≦ a ≦ 루트 N' 이다.
	```
* 따라서 2부터 루트 N까지만 나누어 보면 이 수가 소수인지 아닌지 알 수 있다.

```
코드3> 2 ~ 루트 N 까지 나누는 코드

bool prime (int n) {
    if (n < 2) {
        return false;
    }
    for (int i=2; i * i <= n; i++) {
        if (n%i == 0) {
            return false;
        }
    }    
    return true;
}
```
> 시간복잡도 : O(루트N)

<br/>
<br/>

* 어떤 수 N이 소수인지 아닌지 알아내는데 걸리는 시간 복잡도는 `O(루트N)`이다.
	```
    * N = 백만 -> 루트 N = 1,000
    * N = 1억 -> 루트 N = 10,000
	```
* 그럼, 1부터 1,000,000까지 모든 소수를 구하는데 걸리는 시간 복잡도는 몇일까?
    * 각각의 수 `N`개에 대하여 이 수가 소수인지 아닌지에 대한 검사를 해야하고
    * 각각의 수에 대하여 `O(루트N)`의 시간이 걸린다
    * 즉 전체적으로 `O(N루트N)`의 시간이 걸리는 것이다!
* N = 1,000,000 일때, N루트N을 구하면 10억 = 10초가 걸린다.
* 그래서 이런 경우에는 `'에라토스테네스의 체'`를 사용한다

<br/>
<br/>
<br/>
<br/>

### 에라토스테네스의 체
* 1부터 N까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다.
	```   
    - 2 부터 N까지 모든 수를 써 놓는다
    - 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다
    - 그 수는 소수이다
    - 이제 그 수의 배수를 모두 지운다
    - 이때, 알아내야 하는 것이 3을 지울 때는 `3 × 2`는 이미 지워져 있고
    - 4를 지울 때는 `4 × 3`, `4 × 2`는 이미 지워져 있고
    - 5를 지울 때는 `5 × 4`, `5 × 3`, `5 × 2`는 이미 지워져 있다는 것이다.
    - 즉, 소수 N을 지울 때는 `N의 제곱`부터 지우면 된다는 것이다!!!!
    - 정리하면 어떤 소수 N의 제곱수 기준으로, 제곱수보다 작은 수는 이미 지워져 있고
    - 제곱수를 보다 크거나 같은 수는 이미 지워져 있을 수도 있고, 아닐 수도 있다는 것이다.
    - 그래서 1부터 100까지의 소수를 구할 때, 2부터 7까지만 배수를 지우면 되는 이유가, 7의 다음 소수가 11인데 11의 제곱수는 121로 범위 100을 벗어나기 때문이다.

<br/>
<br/>

```
코드> 에라토스테네스의 체 구현코드

int p[100]; // 소수 저장
int pn = 0; // 소수의 개수
bool c[101]; // 지워졌으면 true
int n = 100; // 100까지의 소수

for (int i=2; i<=n; i++) {
    if (c[i] == false) { //i가 남은 지워지지 않은 수 중 가장 작은 수, 즉 소수 일 경우
        p[pn++] = i; //소수를 저장하고, 소수의 갯수 1 증가
        for (int j = i*i; j <= n; j += i) {
            c[j] = true;
        }
    }
}
```
> 시간복잡도 : O(N로그로그N)

<br/>

안쪽 for문의 시간복잡도가 좀 애매함.<br/> 

`N/2 + N/3 + N/5 + …` 이렇게 계속 가는데, 그 값이 `로그로그N`이 됨.<br/> 
=> 에라토스테네스의 체는 매우 빠르다.

<br/>
<br/>

**이때 주의할 점!**<br/> 
안쪽 for문에서 변수 j의 초기값을 `i * i`로 설정하는데,<br/> 
이때, 입력받은 N의 크기가 커지면 i*i가 정수형의 표현범위를 벗어날 수 있으므로,<br/> 
N의 크기에 따라 `i * i` 혹은 `i * 2`로 설정하는 것이 좋다.<br/> 
(`i * 2`가 문제가 없는 이유는 이미 지운 것을 다시 지워도 상관이 없기 때문!)


<br/>
<br/>
<br/>
<br/>


### 골드바흐의 추측
```
"2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다"
	위 문장에 3을 더하면
“5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다"
	로 바뀜.
아직 증명되진 못하였고, 10 18제곱까지는 참인 것이 증명되었다.

=> 우리가 푸는 수의 범위는 10의 18제곱 이내이므로 참인 명제!
=> `에라토스테네스의 체`를 사용하면 쉽다
```

<br/>
<br/>

#### boj6588)
`'p[i] + ? = N’`(i 번째 소수에다가 ?를 더하면, N이 되!냐를 검증하는 문제)<br/>
-> 에라토스테네스의 체를 활용. 에라토스테네스의 체를 활용하면 범위안의 모든 소수를 구할 수 있다.<br/>
->그 다음 `'N - p[i]'가 소수인지`를 판별해야 하는데, 이때 O(루트N) 방법을 사용하는 것이 아니라,<br/>
 이전에 구했던 에라토스테네스의 체의 소수가 아니면 true,<br/>
 소수가 맞으면 false를 저장해 놓은 c 배열을 사용하여<br/>
`c[ N - p[i] ]`의 값이 false인지 확인하면 된다.<br/>

<br/>

```
코드>

#include <iostream>
using namespace std;
const int MAX = 1000000;
int prime[MAX];
int pn;
bool check[MAX + 1];

int main() {
    for (int i = 2; i <= MAX; i++) {
        if (check[i] == false) {
            prime[pn++] = i;
            for (int j = i+i; j <= MAX; j += i) {
                check[j] = true;
            }
        }
    }
    
    while (true) {
        int n;
        cin >> n;
        if (n == 0) {
            break;
        }
        for (int i = 1; i < pn; i++) {
            if (check[n - prime[i]] == false) {
                cout << n << “ = “ << prime[i] << “ + “ << n - prime[i] << endl;
            }    
        }
    }
    return 0;
}
```


<br/>
<br/>
<br/>
<br/>


# 6. 소인수분해

* 정수 N을 소수의 곱으로 분해
* 소수를 구하지 않고도 해결할 수 있다
* N을 소인수분해 했을 때, 나타날 수 있는 인수 중에서 가장 큰 값은 루트 N이다
* 즉, 2부터 루트N까지 for 문을 돌면서
* N을 나눌 수 있으면, 나눌 수 없을 때까지 계속해서 나누면 된다.

<br/>
<br/>

```
코드>

for (int i = 2; i*i <= n; i++) {
    while (n%i == 0) {
        printf(“%d\n”, i);
        n /= i;
    }
}
if (n > 1) {
    printf(“%d\n”, n);
}
```


<br/>
<br/>
<br/>
<br/>


# 7. 팩토리얼

* 팩토리얼은 매우 큰 값
* N! = 1 × 2 × 3 × … ×  N
* 10! = 3628800(우리가 구할만한 가장 큰 팩토리얼)

<br/>
<br/>

#### boj1676)N!의 0이 몇개 인지 알아보는 문제
```
ex) 10! = 3628800 (여기서 0이 2개인 이유는 10!을 소인수분해 해보면 알 수 있다)
    10! = 1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 × 9 × 10
    10! = 2의 8제곱 × 3의 4제곱 × 5의 제곱 × 7
    10! = 2의 6제곱 × 3의 4제곱 × 7 × 10의 제곱

따라서 10!에는 0이 2개가 존재 한다. (∵ 10의 제×이 있기 때문)
```
-> 2의 제곱수가 5의 제곱수보다 훨씬 많음 <br/>
(∵ N!를 구하는데, 2는 2의 배수마다 나오는데, 5는 5의 배수마다 나오므로, 2의 갯수가 더 많음)<br/>
->N!의 5의 k제곱의 갯수, 즉 k만 구하면 0의 갯수를 구할 수 있다<br/>
<br/>
-> 그래서 100!에서의 5의 갯수를 구하기 위해서는 <br/>
100/5(5의 배수의 갯수) + 100/5의 제곱 (25의 배수의 갯수 -> 25, 50, 75는 5를 두개씩 가지고 있으므로)<br/>
하면 20 + 4 = 24이다.

<br/>
<br/>

#### boj2004)nCm의 0의 갯수를 구하는 문제
-> 조심해야 할 점 : 나누기 연산이 있기 때문에 2의 갯수가 5의 갯수보다 더 적을 수 있다!<br/>
=> 모두 세 줘야 한다!!<br/>


<br/>
<br/>
<br/>
<br/>


to be continue...

<br/>
<br/>
<br/>
<br/>

